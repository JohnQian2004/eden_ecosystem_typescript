{
  "version": 3,
  "sources": ["../../src/flowwise.ts"],
  "sourcesContent": ["/**\r\n * FlowWise Workflow Engine Integration\r\n * Controls the complete lifecycle of chat interactions including\r\n * ledger, cashier, LLM, payment, and notification steps\r\n */\r\n\r\nimport * as fs from \"fs\";\r\nimport * as path from \"path\";\r\n\r\nexport interface WorkflowStep {\r\n  id: string;\r\n  name: string;\r\n  type: \"input\" | \"process\" | \"output\" | \"error\" | \"decision\";\r\n  component: string;\r\n  description: string;\r\n  requiresUserDecision?: boolean;\r\n  decisionPrompt?: string;\r\n  decisionOptions?: Array<{\r\n    value: string;\r\n    label: string;\r\n    action: string;\r\n  }>;\r\n  timeout?: number;\r\n  onTimeout?: string;\r\n  actions?: Array<{\r\n    type: string;\r\n    [key: string]: any;\r\n  }>;\r\n  websocketEvents?: Array<{\r\n    type: string;\r\n    component: string;\r\n    message: string;\r\n    data?: any;\r\n  }>;\r\n  outputs?: Record<string, any>;\r\n  conditions?: Array<{\r\n    if: string;\r\n    then: string;\r\n  }>;\r\n  errorHandling?: {\r\n    onError: string;\r\n    errorEvents?: Array<{\r\n      type: string;\r\n      component: string;\r\n      message: string;\r\n    }>;\r\n  };\r\n}\r\n\r\nexport interface WorkflowTransition {\r\n  from: string;\r\n  to: string;\r\n  condition?: string;\r\n}\r\n\r\nexport interface FlowWiseWorkflow {\r\n  name: string;\r\n  version: string;\r\n  description: string;\r\n  steps: WorkflowStep[];\r\n  transitions: WorkflowTransition[];\r\n  initialStep: string;\r\n  finalSteps: string[];\r\n}\r\n\r\nexport interface WorkflowContext {\r\n  [key: string]: any;\r\n}\r\n\r\nexport interface WorkflowExecution {\r\n  workflowId: string;\r\n  executionId: string; // Unique ID for this execution instance\r\n  currentStep: string;\r\n  context: WorkflowContext;\r\n  history: Array<{\r\n    step: string;\r\n    timestamp: number;\r\n    data?: any;\r\n  }>;\r\n}\r\n\r\n// Dependencies that need to be injected\r\nlet broadcastEvent: (event: any) => void;\r\nlet workflowDataPath: string = path.join(__dirname, \"../data\");\r\n\r\n/**\r\n * Initialize FlowWise with dependencies\r\n */\r\nexport function initializeFlowWise(\r\n  broadcastFn: (event: any) => void,\r\n  dataPath?: string\r\n): void {\r\n  broadcastEvent = broadcastFn;\r\n  if (dataPath) {\r\n    workflowDataPath = dataPath;\r\n  }\r\n  console.log(`\u2705 [FlowWise] Initialized with broadcastEvent: ${typeof broadcastEvent === 'function' ? 'OK' : 'MISSING'}`);\r\n  console.log(`\u2705 [FlowWise] Workflow data path: ${workflowDataPath}`);\r\n}\r\n\r\n/**\r\n * Load workflow definition from JSON file\r\n * DYNAMIC MAPPING: serviceType \u2192 ${serviceType}.json\r\n * Supports any service type without code changes\r\n */\r\nexport function loadWorkflow(serviceType: string): FlowWiseWorkflow | null {\r\n  try {\r\n    // Dynamic filename mapping: ${serviceType}.json\r\n    const filename = `${serviceType}.json`;\r\n    let filePath = path.join(workflowDataPath, filename);\r\n    \r\n    // Backward compatibility: Check for amc_cinema.json if movie.json doesn't exist\r\n    if (!fs.existsSync(filePath) && serviceType === \"movie\") {\r\n      const legacyPath = path.join(workflowDataPath, \"amc_cinema.json\");\r\n      if (fs.existsSync(legacyPath)) {\r\n        console.log(`\u26A0\uFE0F [FlowWise] Using legacy workflow file: amc_cinema.json (consider renaming to movie.json)`);\r\n        filePath = legacyPath;\r\n      }\r\n    }\r\n    \r\n    if (!fs.existsSync(filePath)) {\r\n      console.error(`\u274C [FlowWise] Workflow file not found: ${filePath}`);\r\n      console.error(`\u274C [FlowWise] Expected file: ${filename} in ${workflowDataPath}`);\r\n      return null;\r\n    }\r\n    \r\n    const fileContent = fs.readFileSync(filePath, \"utf-8\");\r\n    const data = JSON.parse(fileContent);\r\n    \r\n    if (!data.flowwiseWorkflow) {\r\n      console.error(`\u274C [FlowWise] No flowwiseWorkflow found in ${filename}`);\r\n      return null;\r\n    }\r\n    \r\n    console.log(`\u2705 [FlowWise] Loaded workflow: ${data.flowwiseWorkflow.name} (${data.flowwiseWorkflow.version || '1.0.0'})`);\r\n    return data.flowwiseWorkflow;\r\n  } catch (error: any) {\r\n    console.error(`\u274C [FlowWise] Error loading workflow:`, error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n// User decision waiting map (executionId -> { stepId, resolve, reject, timeout })\r\nconst pendingDecisions = new Map<string, {\r\n  stepId: string;\r\n  resolve: (decision: string) => void;\r\n  reject: (error: Error) => void;\r\n  timeout: NodeJS.Timeout;\r\n}>();\r\n\r\n/**\r\n * Wait for user decision\r\n */\r\nexport async function waitForUserDecision(\r\n  executionId: string,\r\n  stepId: string,\r\n  timeout: number = 30000\r\n): Promise<string> {\r\n  return new Promise((resolve, reject) => {\r\n    const timeoutHandle = setTimeout(() => {\r\n      pendingDecisions.delete(executionId);\r\n      reject(new Error(`User decision timeout after ${timeout}ms`));\r\n    }, timeout);\r\n    \r\n    pendingDecisions.set(executionId, {\r\n      stepId,\r\n      resolve: (decision: string) => {\r\n        clearTimeout(timeoutHandle);\r\n        pendingDecisions.delete(executionId);\r\n        resolve(decision);\r\n      },\r\n      reject: (error: Error) => {\r\n        clearTimeout(timeoutHandle);\r\n        pendingDecisions.delete(executionId);\r\n        reject(error);\r\n      },\r\n      timeout: timeoutHandle\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Submit user decision\r\n */\r\nexport function submitUserDecision(executionId: string, decision: string): boolean {\r\n  const pending = pendingDecisions.get(executionId);\r\n  if (pending) {\r\n    pending.resolve(decision);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Execute a workflow step\r\n */\r\nasync function executeStep(\r\n  step: WorkflowStep,\r\n  context: WorkflowContext,\r\n  actionHandlers: Map<string, (action: any, context: WorkflowContext) => Promise<any>>,\r\n  executionId: string\r\n): Promise<{ success: boolean; outputs?: Record<string, any>; error?: any }> {\r\n  console.log(`\uD83D\uDD04 [FlowWise] Executing step: ${step.name} (${step.id})`);\r\n  \r\n  try {\r\n    // Handle user decision steps\r\n    if (step.type === \"decision\" && step.requiresUserDecision) {\r\n      console.log(`\uD83E\uDD14 [FlowWise] Waiting for user decision: ${step.decisionPrompt}`);\r\n      \r\n      // Broadcast decision request\r\n      if (step.websocketEvents && broadcastEvent) {\r\n        for (const event of step.websocketEvents) {\r\n          const eventData = replaceTemplateVariables(event.data || {}, context);\r\n          const eventMessage = replaceTemplateVariables(event.message, context);\r\n          \r\n          // Add executionId to event data for response routing\r\n          eventData.workflowId = executionId;\r\n          eventData.stepId = step.id;\r\n          \r\n          broadcastEvent({\r\n            type: event.type,\r\n            component: event.component,\r\n            message: eventMessage,\r\n            timestamp: Date.now(),\r\n            data: eventData\r\n          });\r\n        }\r\n      }\r\n      \r\n      // Wait for user decision\r\n      const timeout = step.timeout || 30000;\r\n      try {\r\n        const userDecision = await waitForUserDecision(executionId, step.id, timeout);\r\n        console.log(`\u2705 [FlowWise] User decision received: ${userDecision}`);\r\n        context.userDecision = userDecision;\r\n        \r\n        // Prepare outputs\r\n        const outputs: Record<string, any> = {};\r\n        if (step.outputs) {\r\n          for (const [key, value] of Object.entries(step.outputs)) {\r\n            outputs[key] = replaceTemplateVariables(value, { ...context, userDecision });\r\n          }\r\n        }\r\n        \r\n        return { success: true, outputs };\r\n      } catch (error: any) {\r\n        console.error(`\u274C [FlowWise] User decision timeout or error:`, error.message);\r\n        if (step.onTimeout) {\r\n          // Route to timeout handler\r\n          return { success: false, error: { type: \"timeout\", message: error.message, routeTo: step.onTimeout } };\r\n        }\r\n        return { success: false, error };\r\n      }\r\n    }\r\n    \r\n    // Execute actions for non-decision steps\r\n    if (step.actions) {\r\n      for (const action of step.actions) {\r\n        const handler = actionHandlers.get(action.type);\r\n        if (handler) {\r\n          const result = await handler(action, context);\r\n          // Merge results into context\r\n          Object.assign(context, result || {});\r\n        } else {\r\n          console.warn(`\u26A0\uFE0F [FlowWise] No handler for action type: ${action.type}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Broadcast WebSocket events\r\n    if (step.websocketEvents && broadcastEvent) {\r\n      for (const event of step.websocketEvents) {\r\n        // Replace template variables in event data\r\n        const eventData = replaceTemplateVariables(event.data || {}, context);\r\n        const eventMessage = replaceTemplateVariables(event.message, context);\r\n        \r\n        broadcastEvent({\r\n          type: event.type,\r\n          component: event.component,\r\n          message: eventMessage,\r\n          timestamp: Date.now(),\r\n          data: eventData\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Prepare outputs\r\n    const outputs: Record<string, any> = {};\r\n    if (step.outputs) {\r\n      for (const [key, value] of Object.entries(step.outputs)) {\r\n        outputs[key] = replaceTemplateVariables(value, context);\r\n      }\r\n    }\r\n    \r\n    console.log(`\u2705 [FlowWise] Step completed: ${step.name}`);\r\n    return { success: true, outputs };\r\n  } catch (error: any) {\r\n    console.error(`\u274C [FlowWise] Step failed: ${step.name}`, error);\r\n    return { success: false, error };\r\n  }\r\n}\r\n\r\n/**\r\n * Replace template variables in strings/objects\r\n */\r\nexport function replaceTemplateVariables(template: any, context: WorkflowContext): any {\r\n  if (typeof template === \"string\") {\r\n    // Check if the entire string is a template variable (e.g., \"{{snapshot}}\")\r\n    const fullMatch = template.match(/^\\{\\{(\\w+(?:\\.\\w+)*)\\}\\}$/);\r\n    if (fullMatch) {\r\n      // If the entire string is a template variable, return the actual value (not stringified)\r\n      const value = getNestedValue(context, fullMatch[1]);\r\n      if (value !== undefined && value !== null) {\r\n        return value; // Return the actual object/value, not stringified\r\n      }\r\n      // Special handling: snapshot.feeSplit should return empty object if snapshot exists but feeSplit doesn't\r\n      if (fullMatch[1] === \"snapshot.feeSplit\" && (context as any).snapshot) {\r\n        return {};\r\n      }\r\n      // Only warn for non-critical missing variables (suppress warning for snapshot.feeSplit as it's handled above)\r\n      if (fullMatch[1] !== \"snapshot.feeSplit\") {\r\n        console.warn(`\u26A0\uFE0F  [Template] Variable not found in context: ${fullMatch[1]}`);\r\n      }\r\n      return null;\r\n    }\r\n    // Otherwise, replace template variables within the string\r\n    return template.replace(/\\{\\{(\\w+(?:\\.\\w+)*)\\}\\}/g, (match, path) => {\r\n      const value = getNestedValue(context, path);\r\n      if (value !== undefined && value !== null) {\r\n        // For objects/arrays, stringify them; for primitives, convert to string\r\n        if (typeof value === 'object') {\r\n          return JSON.stringify(value);\r\n        }\r\n        return String(value);\r\n      }\r\n      // Special handling: snapshot.feeSplit should return empty object string if snapshot exists but feeSplit doesn't\r\n      if (path === \"snapshot.feeSplit\" && (context as any).snapshot) {\r\n        return '{}';\r\n      }\r\n      // If template variable not found, return empty string instead of keeping the template\r\n      // This prevents showing \"{{variableName}}\" in the UI\r\n      // Only warn for non-critical missing variables (suppress warning for snapshot.feeSplit as it's handled above)\r\n      if (path !== \"snapshot.feeSplit\") {\r\n        console.warn(`\u26A0\uFE0F  [Template] Variable not found in context: ${path}`);\r\n      }\r\n      return '';\r\n    });\r\n  } else if (Array.isArray(template)) {\r\n    return template.map(item => replaceTemplateVariables(item, context));\r\n  } else if (template && typeof template === \"object\") {\r\n    const result: any = {};\r\n    for (const [key, value] of Object.entries(template)) {\r\n      result[key] = replaceTemplateVariables(value, context);\r\n    }\r\n    return result;\r\n  }\r\n  return template;\r\n}\r\n\r\n/**\r\n * Get nested value from object using dot notation\r\n */\r\nfunction getNestedValue(obj: any, path: string): any {\r\n  // Special handling: if snapshot.feeSplit is requested, check if snapshot exists first\r\n  if (path === \"snapshot.feeSplit\") {\r\n    if (obj?.snapshot) {\r\n      // Snapshot exists, check if feeSplit exists\r\n      if (obj.snapshot.feeSplit !== undefined && obj.snapshot.feeSplit !== null) {\r\n        return obj.snapshot.feeSplit;\r\n      }\r\n      // Snapshot exists but feeSplit doesn't, return empty object\r\n      return {};\r\n    }\r\n    // Snapshot doesn't exist, return undefined\r\n    return undefined;\r\n  }\r\n  \r\n  // Normal nested property access for other paths\r\n  const parts = path.split(\".\");\r\n  let current = obj;\r\n  \r\n  for (const prop of parts) {\r\n    if (current === null || current === undefined) {\r\n      return undefined;\r\n    }\r\n    current = current[prop];\r\n  }\r\n  \r\n  return current;\r\n}\r\n\r\n/**\r\n * Evaluate condition\r\n */\r\nexport function evaluateCondition(condition: string, context: WorkflowContext): boolean {\r\n  // Simple condition evaluation - can be enhanced\r\n  if (condition === \"always\") return true;\r\n\r\n  // CRITICAL: Handle array length checks first (e.g., {{listings.length}} > 0)\r\n  // This must be done before general template replacement\r\n  let workingCondition = condition;\r\n  if (workingCondition.includes('.length')) {\r\n    const lengthMatches = workingCondition.matchAll(/\\{\\{(\\w+(?:\\.\\w+)*)\\.length\\}\\}/g);\r\n    for (const match of lengthMatches) {\r\n      const arrayPath = match[1];\r\n      const arrayValue = getNestedValue(context, arrayPath);\r\n      const arrayLength = Array.isArray(arrayValue) ? arrayValue.length : (arrayValue?.length || 0);\r\n      \r\n      // Replace {{array.length}} with the actual number\r\n      workingCondition = workingCondition.replace(match[0], String(arrayLength));\r\n      console.log(`   \uD83D\uDD0D [evaluateCondition] Replaced ${match[0]} with ${arrayLength}`);\r\n    }\r\n  }\r\n\r\n  // First, replace template variables in the condition\r\n  let processedCondition = workingCondition;\r\n  processedCondition = processedCondition.replace(/\\{\\{(\\w+(?:\\.\\w+)*)\\}\\}/g, (match, path) => {\r\n    const value = getNestedValue(context, path);\r\n    if (value === undefined || value === null) {\r\n      return 'undefined';\r\n    }\r\n    // If value is an array, evaluate as truthy (exists and has length > 0)\r\n    if (Array.isArray(value)) {\r\n      return value.length > 0 ? 'true' : 'false';\r\n    }\r\n    // If value is a string, wrap it in quotes for comparison\r\n    if (typeof value === 'string') {\r\n      return `'${value}'`;\r\n    }\r\n    // For numbers and booleans, convert to string\r\n    if (typeof value === 'number' || typeof value === 'boolean') {\r\n      return String(value);\r\n    }\r\n    // For objects, check if they exist (truthy)\r\n    return value ? 'true' : 'false';\r\n  });\r\n\r\n  // Handle comparison operators (>, <, >=, <=) - must check before ===\r\n  if (processedCondition.includes(' > ')) {\r\n    const [left, right] = processedCondition.split(' > ').map(s => s.trim());\r\n    const leftNum = parseFloat(left.replace(/^['\"]|['\"]$/g, ''));\r\n    const rightNum = parseFloat(right.replace(/^['\"]|['\"]$/g, ''));\r\n    if (!isNaN(leftNum) && !isNaN(rightNum)) {\r\n      const result = leftNum > rightNum;\r\n      console.log(`   \uD83D\uDD0D [evaluateCondition] Comparison: ${leftNum} > ${rightNum} = ${result}`);\r\n      return result;\r\n    }\r\n  }\r\n  \r\n  if (processedCondition.includes(' < ')) {\r\n    const [left, right] = processedCondition.split(' < ').map(s => s.trim());\r\n    const leftNum = parseFloat(left.replace(/^['\"]|['\"]$/g, ''));\r\n    const rightNum = parseFloat(right.replace(/^['\"]|['\"]$/g, ''));\r\n    if (!isNaN(leftNum) && !isNaN(rightNum)) {\r\n      return leftNum < rightNum;\r\n    }\r\n  }\r\n  \r\n  if (processedCondition.includes(' >= ')) {\r\n    const [left, right] = processedCondition.split(' >= ').map(s => s.trim());\r\n    const leftNum = parseFloat(left.replace(/^['\"]|['\"]$/g, ''));\r\n    const rightNum = parseFloat(right.replace(/^['\"]|['\"]$/g, ''));\r\n    if (!isNaN(leftNum) && !isNaN(rightNum)) {\r\n      return leftNum >= rightNum;\r\n    }\r\n  }\r\n  \r\n  if (processedCondition.includes(' <= ')) {\r\n    const [left, right] = processedCondition.split(' <= ').map(s => s.trim());\r\n    const leftNum = parseFloat(left.replace(/^['\"]|['\"]$/g, ''));\r\n    const rightNum = parseFloat(right.replace(/^['\"]|['\"]$/g, ''));\r\n    if (!isNaN(leftNum) && !isNaN(rightNum)) {\r\n      return leftNum <= rightNum;\r\n    }\r\n  }\r\n\r\n  // Handle comparison operators (===, !==, ==, !=)\r\n  if (processedCondition.includes(' === ')) {\r\n    const [left, right] = processedCondition.split(' === ').map(s => s.trim());\r\n    // Remove quotes if present (handle both single and double quotes)\r\n    const leftValue = left.replace(/^['\"]|['\"]$/g, '');\r\n    const rightValue = right.replace(/^['\"]|['\"]$/g, '');\r\n    const result = leftValue === rightValue;\r\n    console.log(`   \uD83D\uDD0D [evaluateCondition] Comparison: \"${leftValue}\" === \"${rightValue}\" = ${result}`);\r\n    return result;\r\n  }\r\n  \r\n  if (processedCondition.includes(' !== ')) {\r\n    const [left, right] = processedCondition.split(' !== ').map(s => s.trim());\r\n    const leftValue = left.replace(/^'|'$/g, '');\r\n    const rightValue = right.replace(/^'|'$/g, '');\r\n    return leftValue !== rightValue;\r\n  }\r\n\r\n  // Handle boolean string literals (true/false)\r\n  const trimmedProcessed = processedCondition.trim();\r\n  if (trimmedProcessed === 'true') return true;\r\n  if (trimmedProcessed === 'false') return false;\r\n\r\n  // Handle logical operators (&&, ||)\r\n  // CRITICAL: Must check for && and || AFTER handling comparison operators\r\n  // because conditions like \"2 > 0\" need to be evaluated before splitting\r\n  if (processedCondition.includes(' && ')) {\r\n    const parts = processedCondition.split(' && ').map(p => p.trim());\r\n    console.log(`   \uD83D\uDD0D [evaluateCondition] Splitting by &&: [${parts.join(', ')}]`);\r\n    // Evaluate each part recursively\r\n    const results = parts.map((part, index) => {\r\n      // If part is a simple boolean string, return it directly\r\n      if (part === 'true') {\r\n        console.log(`   \uD83D\uDD0D [evaluateCondition] Part ${index} is 'true' \u2192 true`);\r\n        return true;\r\n      }\r\n      if (part === 'false') {\r\n        console.log(`   \uD83D\uDD0D [evaluateCondition] Part ${index} is 'false' \u2192 false`);\r\n        return false;\r\n      }\r\n      // Otherwise, evaluate recursively\r\n      console.log(`   \uD83D\uDD0D [evaluateCondition] Evaluating part ${index} recursively: \"${part}\"`);\r\n      const result = evaluateCondition(part, context);\r\n      console.log(`   \uD83D\uDD0D [evaluateCondition] Part ${index} result: ${result}`);\r\n      return result;\r\n    });\r\n    const finalResult = results.every(r => r === true);\r\n    console.log(`   \uD83D\uDD0D [evaluateCondition] && evaluation result: ${finalResult} (all parts: [${results.join(', ')}])`);\r\n    return finalResult;\r\n  }\r\n  \r\n  if (processedCondition.includes(' || ')) {\r\n    const parts = processedCondition.split(' || ').map(p => p.trim());\r\n    console.log(`   \uD83D\uDD0D [evaluateCondition] Splitting by ||: [${parts.join(', ')}]`);\r\n    // Evaluate each part recursively\r\n    const results = parts.map((part, index) => {\r\n      // If part is a simple boolean string, return it directly\r\n      if (part === 'true') return true;\r\n      if (part === 'false') return false;\r\n      // Otherwise, evaluate recursively\r\n      return evaluateCondition(part, context);\r\n    });\r\n    const finalResult = results.some(r => r === true);\r\n    console.log(`   \uD83D\uDD0D [evaluateCondition] || evaluation result: ${finalResult} (any part: [${results.join(', ')}])`);\r\n    return finalResult;\r\n  }\r\n\r\n  // Handle template syntax {{variable}} (simple existence check)\r\n  const templateMatch = condition.match(/\\{\\{(\\w+(?:\\.\\w+)*)\\}\\}/);\r\n  if (templateMatch) {\r\n    const path = templateMatch[1];\r\n    return !!getNestedValue(context, path);\r\n  }\r\n\r\n  // Handle negation\r\n  if (condition.startsWith(\"!\")) {\r\n    const path = condition.substring(1);\r\n    return !getNestedValue(context, path);\r\n  }\r\n  \r\n  // Default: check if value exists and is truthy\r\n  return !!getNestedValue(context, condition);\r\n}\r\n\r\n/**\r\n * Execute workflow\r\n */\r\nexport async function executeWorkflow(\r\n  workflow: FlowWiseWorkflow,\r\n  initialContext: WorkflowContext,\r\n  actionHandlers: Map<string, (action: any, context: WorkflowContext) => Promise<any>>\r\n): Promise<WorkflowExecution> {\r\n  // Generate unique execution ID for this workflow instance\r\n  const executionId = `workflow-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n  \r\n  const execution: WorkflowExecution = {\r\n    workflowId: workflow.name,\r\n    executionId: executionId,\r\n    currentStep: workflow.initialStep,\r\n    context: { ...initialContext },\r\n    history: []\r\n  };\r\n  \r\n  console.log(`\uD83D\uDE80 [FlowWise] Starting workflow: ${workflow.name}`);\r\n  console.log(`\uD83D\uDCCB [FlowWise] Initial context:`, Object.keys(execution.context));\r\n  \r\n  let currentStepId = workflow.initialStep;\r\n  const stepMap = new Map<string, WorkflowStep>();\r\n  workflow.steps.forEach(step => stepMap.set(step.id, step));\r\n  \r\n  while (currentStepId) {\r\n    const step = stepMap.get(currentStepId);\r\n    if (!step) {\r\n      console.error(`\u274C [FlowWise] Step not found: ${currentStepId}`);\r\n      break;\r\n    }\r\n    \r\n    // Record step start\r\n    execution.history.push({\r\n      step: currentStepId,\r\n      timestamp: Date.now()\r\n    });\r\n    \r\n    // Execute step\r\n    const result = await executeStep(step, execution.context, actionHandlers, execution.executionId);\r\n    \r\n    if (!result.success) {\r\n      // Handle timeout routing\r\n      if (result.error?.routeTo) {\r\n        console.log(`\u26A0\uFE0F [FlowWise] Routing to timeout handler: ${result.error.routeTo}`);\r\n        currentStepId = result.error.routeTo;\r\n        continue;\r\n      }\r\n      \r\n      // Handle error\r\n      if (step.errorHandling) {\r\n        console.log(`\u26A0\uFE0F [FlowWise] Handling error in step: ${currentStepId}`);\r\n        currentStepId = step.errorHandling.onError;\r\n        continue;\r\n      } else {\r\n        console.error(`\u274C [FlowWise] Workflow failed at step: ${currentStepId}`);\r\n        break;\r\n      }\r\n    }\r\n    \r\n    // Merge outputs into context\r\n    if (result.outputs) {\r\n      Object.assign(execution.context, result.outputs);\r\n    }\r\n    \r\n    // Find next step\r\n    const transitions = workflow.transitions.filter(t => t.from === currentStepId);\r\n    let nextStepId: string | null = null;\r\n    \r\n    for (const transition of transitions) {\r\n      if (!transition.condition || evaluateCondition(transition.condition, execution.context)) {\r\n        nextStepId = transition.to;\r\n        break;\r\n      }\r\n    }\r\n    \r\n    // Check if we've reached a final step\r\n    if (workflow.finalSteps.includes(currentStepId)) {\r\n      console.log(`\u2705 [FlowWise] Workflow completed at final step: ${currentStepId}`);\r\n      break;\r\n    }\r\n    \r\n    if (!nextStepId) {\r\n      console.warn(`\u26A0\uFE0F [FlowWise] No valid transition from step: ${currentStepId}`);\r\n      break;\r\n    }\r\n    \r\n    currentStepId = nextStepId;\r\n    execution.currentStep = currentStepId;\r\n  }\r\n  \r\n  console.log(`\uD83C\uDFC1 [FlowWise] Workflow execution completed: ${workflow.name}`);\r\n  return execution;\r\n}\r\n\r\n"],
  "mappings": "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",
  "names": ["outputs", "path"]
}
