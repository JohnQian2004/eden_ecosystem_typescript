{
  "version": 3,
  "sources": ["../../src/chatHistory.ts"],
  "sourcesContent": ["import * as fs from \"fs\";\r\nimport * as path from \"path\";\r\n\r\nexport type ChatRole = \"USER\" | \"ASSISTANT\" | \"SYSTEM\";\r\n\r\nexport interface ChatMessage {\r\n  id: string;\r\n  conversationId: string;\r\n  role: ChatRole;\r\n  content: string;\r\n  timestamp: number;\r\n  userEmail?: string;\r\n  mode?: string;\r\n  scope?: string;\r\n  gardenId?: string;\r\n  serviceType?: string;\r\n  linkedTransactionId?: string;\r\n  status?: \"active\" | \"forgiven\";\r\n}\r\n\r\nconst PERSIST_PATH = path.resolve(__dirname, \"..\", \"eden-chat-history.json\");\r\n\r\ntype Persisted = {\r\n  conversations: Record<string, ChatMessage[]>;\r\n};\r\n\r\nconst state: Persisted = { conversations: {} };\r\n\r\nfunction safeLoad() {\r\n  try {\r\n    if (!fs.existsSync(PERSIST_PATH)) return;\r\n    const raw = fs.readFileSync(PERSIST_PATH, \"utf8\");\r\n    const parsed = JSON.parse(raw);\r\n    if (parsed && typeof parsed === \"object\" && parsed.conversations && typeof parsed.conversations === \"object\") {\r\n      state.conversations = parsed.conversations;\r\n    }\r\n  } catch {\r\n    // non-fatal: start empty\r\n  }\r\n}\r\n\r\n// Persisting the entire chat history JSON on every append can block the event loop (seconds on Windows).\r\n// Use a debounced async write so UI interactions (conversation switching/appends) stay snappy.\r\nconst SAVE_DEBOUNCE_MS = 250;\r\nlet saveTimer: NodeJS.Timeout | null = null;\r\nlet savePending = false;\r\n\r\nfunction scheduleSave() {\r\n  savePending = true;\r\n  if (saveTimer) return;\r\n  saveTimer = setTimeout(async () => {\r\n    saveTimer = null;\r\n    if (!savePending) return;\r\n    savePending = false;\r\n    try {\r\n      await fs.promises.writeFile(PERSIST_PATH, JSON.stringify(state, null, 2), \"utf8\");\r\n    } catch {\r\n      // non-fatal\r\n    }\r\n  }, SAVE_DEBOUNCE_MS);\r\n}\r\n\r\nsafeLoad();\r\n\r\nexport function appendChatMessage(msg: Omit<ChatMessage, \"id\" | \"timestamp\"> & { id?: string; timestamp?: number }): ChatMessage {\r\n  const conversationId = String(msg.conversationId || \"\").trim();\r\n  if (!conversationId.startsWith(\"conv:\")) {\r\n    throw new Error(\"conversationId must start with 'conv:'\");\r\n  }\r\n  const role = msg.role;\r\n  const content = String(msg.content || \"\").trim();\r\n  if (!content) throw new Error(\"content is required\");\r\n\r\n  const full: ChatMessage = {\r\n    id: msg.id || `m_${Date.now()}_${Math.random().toString(16).slice(2)}`,\r\n    conversationId,\r\n    role,\r\n    content,\r\n    timestamp: msg.timestamp || Date.now(),\r\n    userEmail: msg.userEmail,\r\n    mode: msg.mode,\r\n    scope: msg.scope,\r\n    gardenId: msg.gardenId,\r\n    serviceType: msg.serviceType,\r\n    linkedTransactionId: msg.linkedTransactionId,\r\n    status: msg.status || \"active\"\r\n  };\r\n\r\n  if (!state.conversations[conversationId]) state.conversations[conversationId] = [];\r\n  state.conversations[conversationId].push(full);\r\n\r\n  // keep bounded\r\n  if (state.conversations[conversationId].length > 2000) {\r\n    state.conversations[conversationId] = state.conversations[conversationId].slice(-2000);\r\n  }\r\n\r\n  scheduleSave();\r\n  return full;\r\n}\r\n\r\nexport function getConversationMessages(conversationId: string, limit: number = 50, beforeTs?: number): ChatMessage[] {\r\n  const cid = String(conversationId || \"\").trim();\r\n  const all = state.conversations[cid] || [];\r\n  \r\n  // Optimize: If no beforeTs, just take the last N messages directly (faster than filtering)\r\n  if (typeof beforeTs !== \"number\") {\r\n    const maxLimit = Math.max(1, Math.min(500, limit));\r\n    return all.slice(-maxLimit);\r\n  }\r\n  \r\n  // Only filter if beforeTs is provided\r\n  const filtered = all.filter(m => m.timestamp < beforeTs);\r\n  return filtered.slice(-Math.max(1, Math.min(500, limit)));\r\n}\r\n\r\nexport function listConversations(prefix?: string): string[] {\r\n  const pfx = prefix ? String(prefix) : \"\";\r\n  const ids = Object.keys(state.conversations);\r\n  return pfx ? ids.filter(id => id.startsWith(pfx)) : ids;\r\n}\r\n\r\nexport function deleteConversation(conversationId: string): boolean {\r\n  const cid = String(conversationId || \"\").trim();\r\n  if (!cid.startsWith(\"conv:\")) {\r\n    throw new Error(\"conversationId must start with 'conv:'\");\r\n  }\r\n  if (state.conversations[cid]) {\r\n    delete state.conversations[cid];\r\n    scheduleSave();\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function buildConversationId(scope: 'garden' | 'service', id: string, mode: string = 'user'): string {\r\n  const safeId = String(id || '').trim().replace(/\\s+/g, '-');\r\n  return `conv:${scope}:${safeId}:${mode}`;\r\n}\r\n\r\n\r\n"],
  "mappings": "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",
  "names": []
}
