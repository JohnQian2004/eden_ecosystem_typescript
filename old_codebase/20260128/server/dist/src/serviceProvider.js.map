{
  "version": 3,
  "sources": ["../../src/serviceProvider.ts"],
  "sourcesContent": ["/**\r\n * Service Provider Module\r\n * Handles service provider registration, querying, and certificate issuance\r\n */\r\n\r\nimport * as crypto from \"crypto\";\r\nimport type { ServiceProvider, ServiceProviderWithCert, ServiceRegistryQuery, MovieListing, TokenListing, GenericServiceListing } from \"./types\";\r\nimport { GARDENS, TOKEN_GARDENS, ROOT_CA_SERVICE_REGISTRY, CERTIFICATE_REGISTRY, REVOCATION_REGISTRY, DEX_POOLS, ROOT_CA } from \"./state\";\r\nimport type { EdenCertificate } from \"../EdenPKI\";\r\nimport { getServiceRegistry2 } from \"./serviceRegistry2\";\r\nimport { getMySQLProviderPluginConfig } from \"./plugins/providerPluginRegistry\";\r\nimport { testMySQLQuery } from \"./plugins/mysql\";\r\nimport { extractGetDataParamsWithOpenAI, type GetDataParamsResult } from \"./llm\";\r\n\r\n// Dependencies that need to be injected\r\nlet broadcastEvent: (event: any) => void;\r\n\r\n/**\r\n * Initialize service provider module with dependencies\r\n */\r\nexport function initializeServiceProvider(broadcastFn: (event: any) => void): void {\r\n  broadcastEvent = broadcastFn;\r\n}\r\n\r\n// Helper function to validate that a gardenId exists\r\nexport function validateGardenId(gardenId: string | undefined | null): boolean {\r\n  if (!gardenId) {\r\n    return false; // \"HG\" is allowed for infrastructure services, but undefined/null is not\r\n  }\r\n  \r\n  // \"HG\" is always valid (infrastructure services)\r\n  if (gardenId === \"HG\") {\r\n    return true;\r\n  }\r\n  \r\n  // Check if garden exists in GARDENS or TOKEN_GARDENS\r\n  const existsInRegular = GARDENS.some(g => g.id === gardenId);\r\n  const existsInToken = TOKEN_GARDENS.some(tg => tg.id === gardenId);\r\n  \r\n  return existsInRegular || existsInToken;\r\n}\r\n\r\n// Register a service provider with ROOT CA\r\n// CRITICAL: This function now uses ServiceRegistry2 (new implementation) as the primary storage\r\n// ROOT_CA_SERVICE_REGISTRY is kept for backward compatibility only\r\nexport function registerServiceProviderWithROOTCA(provider: ServiceProviderWithCert): void {\r\n  // CRITICAL: Validate that the gardenId exists before registering\r\n  if (provider.gardenId && !validateGardenId(provider.gardenId)) {\r\n    throw new Error(`Cannot register service provider ${provider.id}: gardenId \"${provider.gardenId}\" does not exist. Valid gardens: ${[...GARDENS.map(g => g.id), ...TOKEN_GARDENS.map(tg => tg.id), \"HG\"].join(\", \")}`);\r\n  }\r\n  \r\n  // Use ServiceRegistry2 (new implementation) as primary storage\r\n  try {\r\n    const serviceRegistry2 = getServiceRegistry2();\r\n    \r\n    // Check if provider already exists in ServiceRegistry2\r\n    if (serviceRegistry2.hasProvider(provider.id)) {\r\n      throw new Error(`Service provider ${provider.id} already registered in ServiceRegistry2`);\r\n    }\r\n    \r\n    // Add to ServiceRegistry2\r\n    serviceRegistry2.addProvider(provider);\r\n    console.log(`\u2705 [ServiceRegistry2] Registered service provider: ${provider.name} (${provider.id}) with gardenId: ${provider.gardenId || \"HG\"}`);\r\n  } catch (err: any) {\r\n    // If ServiceRegistry2 is not available, fall back to old system\r\n    if (err.message.includes('not initialized')) {\r\n      console.warn(`\u26A0\uFE0F  [ServiceRegistry2] Not initialized, falling back to ROOT_CA_SERVICE_REGISTRY`);\r\n    } else {\r\n      throw err; // Re-throw if it's a different error\r\n    }\r\n  }\r\n\r\n  // Also add to old ROOT_CA_SERVICE_REGISTRY for backward compatibility (will be removed later)\r\n  const existing = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === provider.id || p.uuid === provider.uuid);\r\n  if (!existing) {\r\n    ROOT_CA_SERVICE_REGISTRY.push(provider);\r\n    console.log(`\u2705 [ROOT CA] Registered service provider (legacy): ${provider.name} (${provider.id}) with gardenId: ${provider.gardenId || \"HG\"}`);\r\n  }\r\n  \r\n  broadcastEvent({\r\n    type: \"service_provider_registered\",\r\n    component: \"root-ca\",\r\n    message: `Service provider registered: ${provider.name}`,\r\n    timestamp: Date.now(),\r\n    data: {\r\n      providerId: provider.id,\r\n      providerName: provider.name,\r\n      serviceType: provider.serviceType,\r\n      gardenId: provider.gardenId\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Generic service provider creation function\r\n * Creates or reassigns service providers for a garden\r\n * Supports both predefined provider IDs and custom provider configurations\r\n */\r\nexport function createServiceProvidersForGarden(\r\n  serviceType: string,\r\n  gardenId: string,\r\n  providers: Array<{\r\n    id?: string;\r\n    name: string;\r\n    location?: string;\r\n    bond?: number;\r\n    reputation?: number;\r\n    apiEndpoint?: string;\r\n    uuid?: string;\r\n    // Optional fields for Snake service type\r\n    insuranceFee?: number;\r\n    iGasMultiplier?: number;\r\n    iTaxMultiplier?: number;\r\n    maxInfluence?: number;\r\n    contextsAllowed?: string[];\r\n    contextsForbidden?: string[];\r\n    adCapabilities?: string[];\r\n  }>,\r\n  predefinedProviderMap?: Record<string, { name: string; uuid: string; location: string; bond: number; reputation: number; apiEndpoint: string }>\r\n): Array<{ providerId: string; providerName: string; created: boolean; assigned: boolean }> {\r\n  const results: Array<{ providerId: string; providerName: string; created: boolean; assigned: boolean }> = [];\r\n  const serviceRegistry2 = getServiceRegistry2();\r\n  \r\n  // Validate garden exists\r\n  if (!validateGardenId(gardenId)) {\r\n    throw new Error(`Cannot create providers: gardenId \"${gardenId}\" does not exist. Valid gardens: ${[...GARDENS.map(g => g.id), ...TOKEN_GARDENS.map(tg => tg.id), \"HG\"].join(\", \")}`);\r\n  }\r\n  \r\n  for (const providerConfig of providers) {\r\n    let providerId: string;\r\n    let providerData: ServiceProviderWithCert;\r\n    \r\n    // Determine provider ID\r\n    if (providerConfig.id) {\r\n      // Use provided ID\r\n      providerId = providerConfig.id;\r\n      \r\n      // Check if it's a predefined provider\r\n      if (predefinedProviderMap && predefinedProviderMap[providerId]) {\r\n        const predefined = predefinedProviderMap[providerId];\r\n        providerData = {\r\n          id: providerId,\r\n          uuid: predefined.uuid,\r\n          name: predefined.name,\r\n          serviceType: serviceType,\r\n          location: predefined.location,\r\n          bond: predefined.bond,\r\n          reputation: predefined.reputation,\r\n          gardenId: gardenId,\r\n          apiEndpoint: predefined.apiEndpoint,\r\n          status: 'active'\r\n        };\r\n      } else {\r\n        // Custom provider with ID\r\n        providerData = {\r\n          id: providerId,\r\n          uuid: providerConfig.uuid || crypto.randomUUID(),\r\n          name: providerConfig.name,\r\n          serviceType: serviceType,\r\n          location: providerConfig.location || 'Unknown',\r\n          bond: providerConfig.bond || 1000,\r\n          reputation: providerConfig.reputation || 5.0,\r\n          gardenId: gardenId,\r\n          apiEndpoint: providerConfig.apiEndpoint || '',\r\n          status: 'active',\r\n          // Optional Snake fields\r\n          insuranceFee: providerConfig.insuranceFee,\r\n          iGasMultiplier: providerConfig.iGasMultiplier,\r\n          iTaxMultiplier: providerConfig.iTaxMultiplier,\r\n          maxInfluence: providerConfig.maxInfluence,\r\n          contextsAllowed: providerConfig.contextsAllowed,\r\n          contextsForbidden: providerConfig.contextsForbidden,\r\n          adCapabilities: providerConfig.adCapabilities\r\n        };\r\n      }\r\n    } else {\r\n      // Generate ID if not provided\r\n      // CRITICAL: Check if a provider with this name already exists for this garden to prevent duplicates\r\n      const existingProviderWithSameName = serviceRegistry2.getAllProviders().find(\r\n        p => p.name === providerConfig.name && p.gardenId === gardenId && p.serviceType === serviceType\r\n      );\r\n      if (existingProviderWithSameName) {\r\n        console.log(`   \u26A0\uFE0F  Provider with name \"${providerConfig.name}\" already exists for garden ${gardenId}, skipping duplicate creation`);\r\n        results.push({\r\n          providerId: existingProviderWithSameName.id,\r\n          providerName: existingProviderWithSameName.name,\r\n          created: false,\r\n          assigned: false\r\n        });\r\n        continue; // Skip creating duplicate\r\n      }\r\n      \r\n      providerId = `${serviceType}-${crypto.randomUUID().substring(0, 8)}`;\r\n      providerData = {\r\n        id: providerId,\r\n        uuid: providerConfig.uuid || crypto.randomUUID(),\r\n        name: providerConfig.name,\r\n        serviceType: serviceType,\r\n        location: providerConfig.location || 'Unknown',\r\n        bond: providerConfig.bond || 1000,\r\n        reputation: providerConfig.reputation || 5.0,\r\n        gardenId: gardenId,\r\n        apiEndpoint: providerConfig.apiEndpoint || '',\r\n        status: 'active',\r\n        // Optional Snake fields\r\n        insuranceFee: providerConfig.insuranceFee,\r\n        iGasMultiplier: providerConfig.iGasMultiplier,\r\n        iTaxMultiplier: providerConfig.iTaxMultiplier,\r\n        maxInfluence: providerConfig.maxInfluence,\r\n        contextsAllowed: providerConfig.contextsAllowed,\r\n        contextsForbidden: providerConfig.contextsForbidden,\r\n        adCapabilities: providerConfig.adCapabilities\r\n      };\r\n    }\r\n    \r\n    // Check if provider already exists\r\n    const existingProvider = serviceRegistry2.getProvider(providerId);\r\n    \r\n    if (existingProvider) {\r\n      // Provider exists - reassign to new garden\r\n      if (existingProvider.gardenId !== gardenId) {\r\n        console.log(`   \uD83D\uDD04 Reassigning provider: ${existingProvider.name} (${existingProvider.id}) from garden ${existingProvider.gardenId} to ${gardenId}`);\r\n        existingProvider.gardenId = gardenId;\r\n        \r\n        // CRITICAL: Save service registry to persistence FIRST, before broadcasting\r\n        try {\r\n          serviceRegistry2.savePersistence();\r\n          console.log(`   \uD83D\uDCBE Service registry saved to persistence (reassigned provider: ${existingProvider.name})`);\r\n        } catch (saveErr: any) {\r\n          console.error(`   \u274C Failed to save service registry:`, saveErr.message);\r\n        }\r\n        \r\n        results.push({\r\n          providerId: providerId,\r\n          providerName: existingProvider.name,\r\n          created: false,\r\n          assigned: true\r\n        });\r\n      } else {\r\n        console.log(`   \u2713 Provider ${existingProvider.name} (${existingProvider.id}) already assigned to garden ${gardenId}`);\r\n        results.push({\r\n          providerId: providerId,\r\n          providerName: existingProvider.name,\r\n          created: false,\r\n          assigned: false\r\n        });\r\n      }\r\n    } else {\r\n      // Provider doesn't exist - create it\r\n      try {\r\n        serviceRegistry2.addProvider(providerData);\r\n        \r\n        // Also add to old ROOT_CA_SERVICE_REGISTRY for backward compatibility\r\n        // CRITICAL: Check if provider already exists in ROOT_CA_SERVICE_REGISTRY to avoid duplicates\r\n        const existingInOldRegistry = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === providerData.id || p.uuid === providerData.uuid);\r\n        if (!existingInOldRegistry) {\r\n          ROOT_CA_SERVICE_REGISTRY.push(providerData);\r\n        } else {\r\n          // Update existing provider in old registry\r\n          Object.assign(existingInOldRegistry, providerData);\r\n        }\r\n        \r\n        // Issue certificate\r\n        try {\r\n          issueServiceProviderCertificate(providerData);\r\n          console.log(`   \uD83D\uDCDC Certificate issued to ${providerData.name}`);\r\n        } catch (certErr: any) {\r\n          console.warn(`   \u26A0\uFE0F  Failed to issue certificate to ${providerData.name}:`, certErr.message);\r\n        }\r\n        \r\n        console.log(`   \u2705 Created service provider: ${providerData.name} (${providerData.id}) for garden ${gardenId}`);\r\n        \r\n        // CRITICAL: Save service registry to persistence FIRST, before broadcasting to Angular\r\n        try {\r\n          serviceRegistry2.savePersistence();\r\n          console.log(`   \uD83D\uDCBE Service registry saved to persistence (provider: ${providerData.name})`);\r\n        } catch (saveErr: any) {\r\n          console.error(`   \u274C Failed to save service registry:`, saveErr.message);\r\n          // Don't throw - continue with broadcast even if save fails\r\n        }\r\n        \r\n        // Broadcast event AFTER persistence\r\n        broadcastEvent({\r\n          type: \"service_provider_created\",\r\n          component: \"root-ca\",\r\n          message: `Service provider ${providerData.name} created and assigned to garden ${gardenId}`,\r\n          timestamp: Date.now(),\r\n          data: {\r\n            providerId: providerData.id,\r\n            providerName: providerData.name,\r\n            serviceType: serviceType,\r\n            gardenId: gardenId\r\n          }\r\n        });\r\n        \r\n        results.push({\r\n          providerId: providerId,\r\n          providerName: providerData.name,\r\n          created: true,\r\n          assigned: true\r\n        });\r\n      } catch (err: any) {\r\n        console.error(`   \u274C Failed to create provider ${providerData.name}:`, err.message);\r\n        throw err;\r\n      }\r\n    }\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\n// Query ROOT CA Service Registry (used by gardens after LLM extraction)\r\n// This is a quick post-LLM in-memory lookup\r\n// CRITICAL: This function now uses ServiceRegistry2 (new implementation) as the primary source\r\nexport function queryROOTCAServiceRegistry(query: ServiceRegistryQuery): ServiceProvider[] {\r\n  // Use ServiceRegistry2 (new implementation) as primary source\r\n  let providers: ServiceProviderWithCert[] = [];\r\n  try {\r\n    const serviceRegistry2 = getServiceRegistry2();\r\n    providers = serviceRegistry2.queryProviders(query.serviceType, query.filters);\r\n    console.log(`\uD83D\uDD0D [queryROOTCAServiceRegistry] ServiceRegistry2 has ${serviceRegistry2.getCount()} providers, query returned ${providers.length}`);\r\n  } catch (err: any) {\r\n    // If ServiceRegistry2 is not available, fall back to old system\r\n    if (err.message.includes('not initialized')) {\r\n      console.warn(`\u26A0\uFE0F  [ServiceRegistry2] Not initialized, falling back to ROOT_CA_SERVICE_REGISTRY`);\r\n      providers = Array.from(ROOT_CA_SERVICE_REGISTRY);\r\n    } else {\r\n      throw err; // Re-throw if it's a different error\r\n    }\r\n  }\r\n  \r\n  // Debug logging\r\n  console.log(`\uD83D\uDD0D [queryROOTCAServiceRegistry] Query:`, JSON.stringify(query, null, 2));\r\n  console.log(`\uD83D\uDD0D [queryROOTCAServiceRegistry] Providers in registry: ${providers.length}`);\r\n  console.log(`\uD83D\uDD0D [queryROOTCAServiceRegistry] Providers:`, providers.map(p => ({\r\n    id: p.id,\r\n    name: p.name,\r\n    serviceType: p.serviceType,\r\n    status: p.status,\r\n    gardenId: p.gardenId\r\n  })));\r\n  \r\n  const filtered = providers.filter((provider) => {\r\n    // Filter out revoked providers\r\n    if (REVOCATION_REGISTRY.has(provider.uuid)) {\r\n      console.log(`   \u274C Provider ${provider.id} filtered out: revoked in REVOCATION_REGISTRY`);\r\n      return false;\r\n    }\r\n    \r\n    // Filter by status if set\r\n    if (provider.status === 'revoked' || provider.status === 'suspended') {\r\n      console.log(`   \u274C Provider ${provider.id} filtered out: status is ${provider.status}`);\r\n      return false;\r\n    }\r\n    \r\n    // Filter by service type (if specified)\r\n    // Snake is a service type (serviceType: \"snake\"), not a provider type\r\n    if (query.serviceType && provider.serviceType !== query.serviceType) {\r\n      console.log(`   \u274C Provider ${provider.id} filtered out: serviceType mismatch (query: ${query.serviceType}, provider: ${provider.serviceType})`);\r\n      return false;\r\n    }\r\n    \r\n    // Filter by location if provided\r\n    if (query.filters?.location && !provider.location.toLowerCase().includes(query.filters.location.toLowerCase())) {\r\n      console.log(`   \u274C Provider ${provider.id} filtered out: location mismatch (query: ${query.filters.location}, provider: ${provider.location})`);\r\n      return false;\r\n    }\r\n    \r\n    // Note: maxPrice filter is applied after querying provider APIs (prices come from APIs, not registry)\r\n    if (query.filters?.minReputation && provider.reputation < query.filters.minReputation) {\r\n      console.log(`   \u274C Provider ${provider.id} filtered out: reputation too low (query: ${query.filters.minReputation}, provider: ${provider.reputation})`);\r\n      return false;\r\n    }\r\n    \r\n    console.log(`   \u2705 Provider ${provider.id} matched!`);\r\n    return true;\r\n  });\r\n  \r\n  console.log(`\uD83D\uDD0D [queryROOTCAServiceRegistry] Filtered result: ${filtered.length} providers`);\r\n  return filtered;\r\n}\r\n\r\n// Query AMC API\r\nexport async function queryAMCAPI(location: string, filters?: { genre?: string; time?: string }): Promise<MovieListing[]> {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 50));\r\n  \r\n  // Get the actual gardenId from the provider registry (match old codebase behavior)\r\n  const amcProvider = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === \"amc-001\");\r\n  const gardenId = amcProvider?.gardenId || \"unknown\"; // Fallback to \"unknown\" if not found (old codebase behavior)\r\n  \r\n  if (!amcProvider) {\r\n    console.warn(`\u26A0\uFE0F  [queryAMCAPI] Provider amc-001 not found in ROOT_CA_SERVICE_REGISTRY. Using fallback gardenId: ${gardenId}`);\r\n    // Return hardcoded \"Back to the Future 1\" if provider not found\r\n    return [\r\n      {\r\n        providerId: \"amc-001\",\r\n        providerName: \"AMC Theatres\",\r\n        movieTitle: \"Back to the Future\",\r\n        movieId: \"back-to-future-1\",\r\n        price: 2.0,\r\n        showtime: \"10:30 PM\",\r\n        location: location || \"Baltimore, Maryland\",\r\n        reviewCount: 100,\r\n        rating: 5.0,\r\n        gardenId: gardenId\r\n      }\r\n    ];\r\n  } else if (!amcProvider.gardenId) {\r\n    console.warn(`\u26A0\uFE0F  [queryAMCAPI] Provider amc-001 found but has no gardenId. Using fallback: ${gardenId}`);\r\n    // Return hardcoded \"Back to the Future 1\" if no gardenId\r\n    return [\r\n      {\r\n        providerId: \"amc-001\",\r\n        providerName: \"AMC Theatres\",\r\n        movieTitle: \"Back to the Future\",\r\n        movieId: \"back-to-future-1\",\r\n        price: 2.0,\r\n        showtime: \"10:30 PM\",\r\n        location: location || \"Baltimore, Maryland\",\r\n        reviewCount: 100,\r\n        rating: 5.0,\r\n        gardenId: gardenId\r\n      }\r\n    ];\r\n  }\r\n  console.log(`\u2705 [queryAMCAPI] Found amc-001 with gardenId: ${gardenId}`);\r\n  \r\n  // Mock AMC API response with real-time pricing\r\n  return [\r\n    {\r\n      providerId: \"amc-001\",\r\n      providerName: \"AMC Theatres\",\r\n      movieTitle: \"Back to the Future\",\r\n      movieId: \"back-to-future-1\",\r\n      price: 2.0, // Real-time price from AMC API\r\n      showtime: \"10:30 PM\",\r\n      location: location,\r\n      reviewCount: 100,\r\n      rating: 5.0,\r\n      gardenId: gardenId\r\n    },\r\n    {\r\n      providerId: \"amc-001\",\r\n      providerName: \"AMC Theatres\",\r\n      movieTitle: \"The Matrix\",\r\n      movieId: \"matrix-001\",\r\n      price: 2.0, // Real-time price from AMC API\r\n      showtime: \"8:00 PM\",\r\n      location: location,\r\n      reviewCount: 150,\r\n      rating: 4.9,\r\n      gardenId: gardenId\r\n    },\r\n  ];\r\n}\r\n\r\n// Query Movie.com API\r\nexport async function queryMovieComAPI(location: string, filters?: { genre?: string; time?: string }): Promise<MovieListing[]> {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 50));\r\n  \r\n  // Get the actual gardenId from the provider registry (match old codebase behavior)\r\n  const moviecomProvider = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === \"moviecom-001\");\r\n  const gardenId = moviecomProvider?.gardenId || \"unknown\"; // Fallback to \"unknown\" if not found (old codebase behavior)\r\n  \r\n  if (!moviecomProvider) {\r\n    console.warn(`\u26A0\uFE0F  [queryMovieComAPI] Provider moviecom-001 not found in ROOT_CA_SERVICE_REGISTRY. Using fallback gardenId: ${gardenId}`);\r\n    // Return hardcoded \"Back to the Future 1\" if provider not found\r\n    return [\r\n      {\r\n        providerId: \"moviecom-001\",\r\n        providerName: \"MovieCom\",\r\n        movieTitle: \"Back to the Future\",\r\n        movieId: \"back-to-future-1\",\r\n        price: 1.5,\r\n        showtime: \"9:45 PM\",\r\n        location: location || \"Baltimore, Maryland\",\r\n        reviewCount: 85,\r\n        rating: 4.7,\r\n        gardenId: gardenId\r\n      }\r\n    ];\r\n  } else if (!moviecomProvider.gardenId) {\r\n    console.warn(`\u26A0\uFE0F  [queryMovieComAPI] Provider moviecom-001 found but has no gardenId. Using fallback: ${gardenId}`);\r\n    // Return hardcoded \"Back to the Future 1\" if no gardenId\r\n    return [\r\n      {\r\n        providerId: \"moviecom-001\",\r\n        providerName: \"MovieCom\",\r\n        movieTitle: \"Back to the Future\",\r\n        movieId: \"back-to-future-1\",\r\n        price: 1.5,\r\n        showtime: \"9:45 PM\",\r\n        location: location || \"Baltimore, Maryland\",\r\n        reviewCount: 85,\r\n        rating: 4.7,\r\n        gardenId: gardenId\r\n      }\r\n    ];\r\n  }\r\n  console.log(`\u2705 [queryMovieComAPI] Found moviecom-001 with gardenId: ${gardenId}`);\r\n  \r\n  // Mock MovieCom API response with real-time pricing\r\n  return [\r\n    {\r\n      providerId: \"moviecom-001\",\r\n      providerName: \"MovieCom\",\r\n      movieTitle: \"Back to the Future\",\r\n      movieId: \"back-to-future-1\",\r\n      price: 1.5, // Real-time price from MovieCom API\r\n      showtime: \"9:45 PM\",\r\n      location: location,\r\n      reviewCount: 85,\r\n      rating: 4.7,\r\n      gardenId: gardenId\r\n    },\r\n  ];\r\n}\r\n\r\n// Query Cinemark API\r\nexport async function queryCinemarkAPI(location: string, filters?: { genre?: string; time?: string }): Promise<MovieListing[]> {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 50));\r\n  \r\n  // Get the actual gardenId from the provider registry (match old codebase behavior)\r\n  const cinemarkProvider = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === \"cinemark-001\");\r\n  const gardenId = cinemarkProvider?.gardenId || \"unknown\"; // Fallback to \"unknown\" if not found (old codebase behavior)\r\n  \r\n  if (!cinemarkProvider) {\r\n    console.warn(`\u26A0\uFE0F  [queryCinemarkAPI] Provider cinemark-001 not found in ROOT_CA_SERVICE_REGISTRY. Using fallback gardenId: ${gardenId}`);\r\n    // Return hardcoded \"Back to the Future 1\" if provider not found\r\n    return [\r\n      {\r\n        providerId: \"cinemark-001\",\r\n        providerName: \"Cinemark\",\r\n        movieTitle: \"Back to the Future\",\r\n        movieId: \"back-to-future-1\",\r\n        price: 2.5,\r\n        showtime: \"11:00 PM\",\r\n        location: location || \"Baltimore, Maryland\",\r\n        reviewCount: 120,\r\n        rating: 4.8,\r\n        gardenId: gardenId\r\n      }\r\n    ];\r\n  } else if (!cinemarkProvider.gardenId) {\r\n    console.warn(`\u26A0\uFE0F  [queryCinemarkAPI] Provider cinemark-001 found but has no gardenId. Using fallback: ${gardenId}`);\r\n    // Return hardcoded \"Back to the Future 1\" if no gardenId\r\n    return [\r\n      {\r\n        providerId: \"cinemark-001\",\r\n        providerName: \"Cinemark\",\r\n        movieTitle: \"Back to the Future\",\r\n        movieId: \"back-to-future-1\",\r\n        price: 2.5,\r\n        showtime: \"11:00 PM\",\r\n        location: location || \"Baltimore, Maryland\",\r\n        reviewCount: 120,\r\n        rating: 4.8,\r\n        gardenId: gardenId\r\n      }\r\n    ];\r\n  }\r\n  console.log(`\u2705 [queryCinemarkAPI] Found cinemark-001 with gardenId: ${gardenId}`);\r\n  \r\n  // Mock Cinemark API response with real-time pricing\r\n  return [\r\n    {\r\n      providerId: \"cinemark-001\",\r\n      providerName: \"Cinemark\",\r\n      movieTitle: \"The Matrix\",\r\n      movieId: \"matrix-001\",\r\n      price: 2.5, // Real-time price from Cinemark API\r\n      showtime: \"11:00 PM\",\r\n      location: location,\r\n      reviewCount: 120,\r\n      rating: 4.8,\r\n      gardenId: gardenId\r\n    },\r\n  ];\r\n}\r\n\r\n// Query DEX Pool API\r\nexport async function queryDEXPoolAPI(provider: ServiceProvider, filters?: { tokenSymbol?: string; baseToken?: string; action?: 'BUY' | 'SELL' }): Promise<TokenListing[]> {\r\n  await new Promise(resolve => setTimeout(resolve, 30));\r\n  \r\n  // Check if provider exists in registry and has gardenId\r\n  const providerInRegistry = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === provider.id);\r\n  if (!providerInRegistry) {\r\n    console.warn(`\u26A0\uFE0F  [queryDEXPoolAPI] Provider ${provider.id} not found in ROOT_CA_SERVICE_REGISTRY. Total providers: ${ROOT_CA_SERVICE_REGISTRY.length}`);\r\n    console.warn(`\u26A0\uFE0F  [queryDEXPoolAPI] Available providers: ${ROOT_CA_SERVICE_REGISTRY.map(p => p.id).join(', ')}`);\r\n    return [];\r\n  }\r\n  if (!provider.gardenId) {\r\n    console.warn(`\u26A0\uFE0F  [queryDEXPoolAPI] Provider ${provider.id} found but has no gardenId`);\r\n    return [];\r\n  }\r\n  console.log(`\u2705 [queryDEXPoolAPI] Found provider ${provider.id} with gardenId: ${provider.gardenId}`);\r\n  \r\n  // Check if DEX_POOLS has any pools\r\n  if (DEX_POOLS.size === 0) {\r\n    console.warn(`\u26A0\uFE0F  [queryDEXPoolAPI] DEX_POOLS is empty! No pools available.`);\r\n    console.warn(`\u26A0\uFE0F  [queryDEXPoolAPI] TOKEN_GARDENS.length: ${TOKEN_GARDENS.length}`);\r\n    console.warn(`\u26A0\uFE0F  [queryDEXPoolAPI] TOKEN_GARDENS:`, TOKEN_GARDENS.map(tg => ({ id: tg.id, name: tg.name })));\r\n    console.warn(`\u26A0\uFE0F  [queryDEXPoolAPI] DEX_POOLS reference:`, DEX_POOLS);\r\n    console.warn(`\u26A0\uFE0F  [queryDEXPoolAPI] DEX_POOLS entries:`, Array.from(DEX_POOLS.entries()));\r\n    return [];\r\n  }\r\n  console.log(`\u2705 [queryDEXPoolAPI] DEX_POOLS has ${DEX_POOLS.size} pool(s)`);\r\n  console.log(`\u2705 [queryDEXPoolAPI] DEX_POOLS entries:`, Array.from(DEX_POOLS.entries()).map(([id, pool]) => ({\r\n    poolId: id,\r\n    tokenSymbol: pool.tokenSymbol,\r\n    gardenId: pool.gardenId\r\n  })));\r\n  \r\n  const listings: TokenListing[] = [];\r\n  \r\n  console.log(`\uD83D\uDD0D [DEX] Querying pools for provider: ${provider.id} (gardenId: ${provider.gardenId})`);\r\n  console.log(`   Filters: ${JSON.stringify(filters)}`);\r\n  \r\n  // Find pools matching the provider\r\n  // Match by: 1) provider.gardenId matches pool.gardenId, OR 2) provider.id contains token symbol\r\n  // If no specific match, return all pools for DEX providers (fallback)\r\n  let hasMatch = false;\r\n  for (const [poolId, pool] of DEX_POOLS.entries()) {\r\n    const tokenSymbolLower = pool.tokenSymbol.toLowerCase();\r\n    const providerIdLower = provider.id.toLowerCase();\r\n    \r\n    // Match by garden ID (most reliable)\r\n    const matchesByGarden = pool.gardenId === provider.gardenId;\r\n    \r\n    // Match by token symbol in provider ID (e.g., \"dex-pool-tokena\" contains \"tokena\")\r\n    const matchesBySymbol = providerIdLower.includes(tokenSymbolLower);\r\n    \r\n    // Also check if provider ID matches the expected pattern \"dex-pool-{tokenSymbol}\"\r\n    const expectedProviderId = `dex-pool-${tokenSymbolLower}`;\r\n    const matchesByPattern = providerIdLower === expectedProviderId;\r\n    \r\n    const matchesProvider = matchesByGarden || matchesBySymbol || matchesByPattern;\r\n    \r\n    if (matchesProvider) hasMatch = true;\r\n    \r\n    console.log(`   Pool ${pool.tokenSymbol} (${pool.gardenId}): matchesByGarden=${matchesByGarden}, matchesBySymbol=${matchesBySymbol}, matchesByPattern=${matchesByPattern} (provider.id=\"${provider.id}\", expected=\"${expectedProviderId}\")`);\r\n    \r\n    if (!matchesProvider) continue;\r\n    \r\n    // Apply filters\r\n    if (filters?.tokenSymbol && pool.tokenSymbol.toUpperCase() !== filters.tokenSymbol.toUpperCase()) {\r\n      console.log(`   Pool ${pool.tokenSymbol} filtered out by tokenSymbol filter: ${pool.tokenSymbol.toUpperCase()} !== ${filters.tokenSymbol.toUpperCase()}`);\r\n      continue;\r\n    }\r\n    if (filters?.baseToken && pool.baseToken.toUpperCase() !== filters.baseToken.toUpperCase()) {\r\n      console.log(`   Pool ${pool.tokenSymbol} filtered out by baseToken filter: ${pool.baseToken.toUpperCase()} !== ${filters.baseToken.toUpperCase()}`);\r\n      continue;\r\n    }\r\n    \r\n    console.log(`   \u2705 Pool ${pool.tokenSymbol} matched!`);\r\n    listings.push({\r\n      poolId: pool.poolId,\r\n      providerId: provider.id,\r\n      providerName: provider.name,\r\n      tokenSymbol: pool.tokenSymbol,\r\n      tokenName: pool.tokenName,\r\n      baseToken: pool.baseToken,\r\n      price: pool.price,\r\n      liquidity: pool.poolLiquidity,\r\n      volume24h: pool.totalVolume,\r\n      gardenId: pool.gardenId,\r\n    });\r\n  }\r\n  \r\n  // Debug logging\r\n  if (listings.length === 0) {\r\n    console.log(`\u26A0\uFE0F  [DEX] No pools matched for provider ${provider.id} (gardenId: ${provider.gardenId})`);\r\n    console.log(`   Available pools: ${Array.from(DEX_POOLS.values()).map(p => `${p.tokenSymbol} (${p.gardenId})`).join(\", \")}`);\r\n    \r\n    // Fallback: If this is a DEX provider but no pools matched, return all pools for this garden\r\n    // This handles edge cases where matching logic might fail\r\n    if (!hasMatch && provider.serviceType === \"dex\") {\r\n      console.log(`   \uD83D\uDD04 Fallback: Returning all pools for garden ${provider.gardenId}`);\r\n      for (const [poolId, pool] of DEX_POOLS.entries()) {\r\n        if (pool.gardenId === provider.gardenId) {\r\n          // Apply filters\r\n          if (filters?.tokenSymbol && pool.tokenSymbol.toUpperCase() !== filters.tokenSymbol.toUpperCase()) continue;\r\n          if (filters?.baseToken && pool.baseToken.toUpperCase() !== filters.baseToken.toUpperCase()) continue;\r\n          \r\n          listings.push({\r\n            poolId: pool.poolId,\r\n            providerId: provider.id,\r\n            providerName: provider.name,\r\n            tokenSymbol: pool.tokenSymbol,\r\n            tokenName: pool.tokenName,\r\n            baseToken: pool.baseToken,\r\n            price: pool.price,\r\n            liquidity: pool.poolLiquidity,\r\n            volume24h: pool.totalVolume,\r\n            gardenId: pool.gardenId,\r\n          });\r\n        }\r\n      }\r\n      if (listings.length > 0) {\r\n        console.log(`   \u2705 Fallback found ${listings.length} pool(s)`);\r\n      }\r\n    }\r\n  } else {\r\n    console.log(`\u2705 [DEX] Found ${listings.length} pool(s) for provider ${provider.id}`);\r\n  }\r\n  \r\n  return listings;\r\n}\r\n\r\n// Provider API router\r\n// Mock Snake (Advertising) Provider API\r\nexport async function querySnakeAPI(provider: ServiceProvider, filters?: { genre?: string; time?: string }): Promise<MovieListing[]> {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 50));\r\n  \r\n  // Snake providers return enhanced/advertised listings\r\n  // For testing: Return movie listings with Snake provider metadata\r\n  const baseListings: MovieListing[] = [\r\n    {\r\n      providerId: provider.id,\r\n      providerName: provider.name,\r\n      movieTitle: \"Premium Cinema Experience\",\r\n      movieId: \"premium-cinema-001\",\r\n      price: 18.99, // Slightly higher price (premium)\r\n      showtime: filters?.time || \"8:00 PM\",\r\n      location: \"Premium Theater District\",\r\n      reviewCount: 1250,\r\n      rating: 4.7,\r\n      gardenId: provider.gardenId\r\n    },\r\n    {\r\n      providerId: provider.id,\r\n      providerName: provider.name,\r\n      movieTitle: \"VIP Movie Night\",\r\n      movieId: \"vip-movie-001\",\r\n      price: 22.50, // Premium pricing\r\n      showtime: filters?.time || \"9:30 PM\",\r\n      location: \"Luxury Cinema Complex\",\r\n      reviewCount: 890,\r\n      rating: 4.8,\r\n      gardenId: provider.gardenId\r\n    }\r\n  ];\r\n  \r\n  console.log(`\uD83D\uDC0D [Snake Provider] ${provider.name} returned ${baseListings.length} advertised listings`);\r\n  return baseListings;\r\n}\r\n\r\nexport async function queryProviderAPI(\r\n  provider: ServiceProvider,\r\n  filters?: { genre?: string; time?: string; tokenSymbol?: string; baseToken?: string; action?: 'BUY' | 'SELL'; [key: string]: any }\r\n): Promise<MovieListing[] | TokenListing[] | GenericServiceListing[]> {\r\n  // Handle Snake services (serviceType: \"snake\")\r\n  // Snake is a service type, each Snake service belongs to a garden\r\n  if (provider.serviceType === \"snake\") {\r\n    return await querySnakeAPI(provider, filters);\r\n  }\r\n  \r\n  // Handle DEX providers\r\n  if (provider.serviceType === \"dex\") {\r\n    return await queryDEXPoolAPI(provider, filters);\r\n  }\r\n  \r\n  // Handle regular movie providers\r\n  switch (provider.id) {\r\n    case \"amc-001\":\r\n      return await queryAMCAPI(provider.location, filters);\r\n    case \"moviecom-001\":\r\n      return await queryMovieComAPI(provider.location, filters);\r\n    case \"cinemark-001\":\r\n      return await queryCinemarkAPI(provider.location, filters);\r\n    default:\r\n      // Provider plugin fallback (SQL-backed providers)\r\n      if (String(provider.apiEndpoint || \"\").toLowerCase().startsWith(\"eden:plugin:mysql\")) {\r\n        const cfg = getMySQLProviderPluginConfig(provider.id);\r\n        if (!cfg) {\r\n          throw new Error(`MySQL plugin config not found for provider: ${provider.id}`);\r\n        }\r\n\r\n        // ROOT CA LLM Integration: Use GOD-controlled getData() parameter extraction\r\n        // If filters contain a raw user query, use ROOT CA LLM to extract structured params\r\n        let params: any[] = [];\r\n        const paramOrder = Array.isArray(cfg.paramOrder) ? cfg.paramOrder : [];\r\n        \r\n        // Check if filters contain a raw query (from ROOT CA LLM extraction)\r\n        if (filters && typeof (filters as any).rawQuery === \"string\" && (filters as any).rawQuery.trim()) {\r\n          console.log(`   \uD83D\uDC51 [Provider Plugin] ROOT CA LLM: Extracting getData() params from raw query`);\r\n          try {\r\n            const getDataParams = await extractGetDataParamsWithOpenAI((filters as any).rawQuery);\r\n            // Map getData() params to SQL params based on paramOrder\r\n            params = paramOrder.map(k => {\r\n              // Try to match getData() params to paramOrder keys\r\n              const matchedParam = getDataParams.params.find((p: string) => \r\n                p.toLowerCase().includes(k.toLowerCase()) || k.toLowerCase().includes(p.toLowerCase())\r\n              );\r\n              return matchedParam || (filters as any)?.[k];\r\n            });\r\n            console.log(`   \uD83D\uDC51 [Provider Plugin] ROOT CA LLM extracted params:`, getDataParams.params);\r\n            console.log(`   \uD83D\uDC51 [Provider Plugin] Mapped to SQL params:`, params);\r\n          } catch (llmErr: any) {\r\n            console.warn(`   \u26A0\uFE0F  [Provider Plugin] ROOT CA LLM extraction failed, falling back to direct filters:`, llmErr.message);\r\n            params = paramOrder.map(k => (filters as any)?.[k]);\r\n          }\r\n        } else {\r\n          // Standard parameter mapping (backward compatibility)\r\n          params = paramOrder.map(k => (filters as any)?.[k]);\r\n        }\r\n\r\n        const result = await testMySQLQuery({\r\n          connection: cfg.connection,\r\n          sql: cfg.sql,\r\n          params,\r\n          maxRows: cfg.maxRows || 50,\r\n        });\r\n\r\n        const fieldMap = cfg.fieldMap || {};\r\n        const rows = result.rows || [];\r\n\r\n        // Helper function to normalize BigInt values for JSON serialization\r\n        const normalizeBigInt = (value: any): any => {\r\n          if (typeof value === 'bigint') {\r\n            // Convert BigInt to Number if within safe integer range, otherwise to String\r\n            if (value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER) {\r\n              return Number(value);\r\n            } else {\r\n              return value.toString();\r\n            }\r\n          }\r\n          if (Array.isArray(value)) {\r\n            return value.map(normalizeBigInt);\r\n          }\r\n          if (value !== null && typeof value === 'object') {\r\n            const normalized: any = {};\r\n            for (const [k, v] of Object.entries(value)) {\r\n              normalized[k] = normalizeBigInt(v);\r\n            }\r\n            return normalized;\r\n          }\r\n          return value;\r\n        };\r\n\r\n        // Check if this is an autoparts query with images (has both autopart and image columns)\r\n        const hasImageColumns = rows.length > 0 && (\r\n          'autopart_id' in rows[0] || \r\n          'image_id' in rows[0] || \r\n          'image_url' in rows[0] ||\r\n          'i.id' in rows[0] ||\r\n          Object.keys(rows[0]).some(k => k.startsWith('image_') || k.startsWith('i.') || k.toLowerCase().includes('image'))\r\n        );\r\n        const hasAutopartId = rows.length > 0 && (\r\n          'id' in rows[0] || \r\n          'a.id' in rows[0] ||\r\n          'autopart_id' in rows[0]\r\n        );\r\n\r\n        // If this is autoparts with images, group by autopart ID\r\n        if (cfg.serviceType === \"autoparts\" && hasImageColumns && hasAutopartId) {\r\n          console.log(`   \uD83D\uDD04 [Provider Plugin] Grouping autoparts with images (${rows.length} rows)`);\r\n          \r\n          // Group rows by autopart ID\r\n          const autopartsMap = new Map<number | string, any>();\r\n          \r\n          for (const row of rows) {\r\n            // Determine autopart ID (could be 'id', 'a.id', or 'autopart_id')\r\n            const autopartId = row.id || row['a.id'] || row.autopart_id || row['a.id'];\r\n            if (!autopartId) continue;\r\n\r\n            // Get or create autopart entry\r\n            if (!autopartsMap.has(autopartId)) {\r\n              const autopart: any = {\r\n                providerId: provider.id,\r\n                providerName: provider.name,\r\n                gardenId: provider.gardenId,\r\n                location: provider.location,\r\n                imageModals: [] as any[]\r\n              };\r\n\r\n              // Copy autopart columns (columns starting with 'a.' or direct columns that aren't image-related)\r\n              for (const [k, v] of Object.entries(row || {})) {\r\n                // Skip image columns (they'll be in imageModals)\r\n                // Skip columns that start with 'image_' prefix or are image-related\r\n                if (k.startsWith('image_') || k.startsWith('i.') || (k.toLowerCase().includes('image') && k !== 'imageModals') || k === 'autopart_id') {\r\n                  continue;\r\n                }\r\n                // Copy autopart columns and normalize BigInt values\r\n                if (k.startsWith('a.')) {\r\n                  const cleanKey = k.substring(2); // Remove 'a.' prefix\r\n                  autopart[cleanKey] = normalizeBigInt(v);\r\n                } else {\r\n                  autopart[k] = normalizeBigInt(v);\r\n                }\r\n              }\r\n\r\n              // Canonical field mapping for autopart\r\n              for (const [canonical, col] of Object.entries(fieldMap)) {\r\n                if (row[col] !== undefined) {\r\n                  autopart[canonical] = normalizeBigInt(row[col]);\r\n                }\r\n              }\r\n\r\n              // Ensure price exists\r\n              if (autopart.price === undefined || autopart.price === null) {\r\n                const maybePrice = autopart.Price ?? autopart.price_usd ?? autopart.amount ?? autopart.cost ?? autopart.sale_price;\r\n                autopart.price = typeof maybePrice === \"string\" ? parseFloat(maybePrice) : (typeof maybePrice === \"number\" ? maybePrice : 0);\r\n              }\r\n\r\n              // Autoparts workflow expects partName/partNumber/category/etc\r\n              if (!autopart.partName && autopart.part_name) autopart.partName = autopart.part_name;\r\n              if (!autopart.partName && autopart.title) autopart.partName = autopart.title;\r\n\r\n              autopartsMap.set(autopartId, autopart);\r\n            }\r\n\r\n            // Add image to imageModals if image data exists\r\n            const autopart = autopartsMap.get(autopartId)!;\r\n            const imageData: any = {};\r\n            let hasImageData = false;\r\n\r\n            // Extract image columns (columns prefixed with 'image_' or specific image fields)\r\n            for (const [k, v] of Object.entries(row || {})) {\r\n              // Handle aliased image columns (image_id, image_url, image_alt, etc.)\r\n              if (k.startsWith('image_')) {\r\n                const cleanKey = k.substring(6); // Remove 'image_' prefix\r\n                if (v !== null && v !== undefined) {\r\n                  imageData[cleanKey] = normalizeBigInt(v);\r\n                  hasImageData = true;\r\n                }\r\n              } else if (k === 'autopart_id' && v !== null && v !== undefined) {\r\n                // Keep autopart_id for reference\r\n                imageData[k] = normalizeBigInt(v);\r\n              } else if (k.startsWith('i.')) {\r\n                // Handle 'i.' prefixed columns (fallback)\r\n                const cleanKey = k.substring(2);\r\n                if (v !== null && v !== undefined) {\r\n                  imageData[cleanKey] = normalizeBigInt(v);\r\n                  hasImageData = true;\r\n                }\r\n              }\r\n            }\r\n\r\n            // Only add image if it has data (not null/undefined)\r\n            if (hasImageData && Object.keys(imageData).length > 0) {\r\n              // Avoid duplicates (check if image with same ID already exists)\r\n              const imageId = imageData.id || imageData.image_id;\r\n              if (imageId && !autopart.imageModals.find((img: any) => (img.id || img.image_id) === imageId)) {\r\n                autopart.imageModals.push(imageData);\r\n              } else if (!imageId) {\r\n                // If no ID, check by URL or other unique field to avoid duplicates\r\n                const imageUrl = imageData.url || imageData.image_url;\r\n                if (imageUrl && !autopart.imageModals.find((img: any) => (img.url || img.image_url) === imageUrl)) {\r\n                  autopart.imageModals.push(imageData);\r\n                } else if (!imageUrl) {\r\n                  // If no unique identifier, just add it (might be a duplicate, but better than losing data)\r\n                  autopart.imageModals.push(imageData);\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // No hardcoded filtering - return all fields from grouped autoparts\r\n          // Field filtering is controlled by returnFields parameter in test-getdata endpoint\r\n          const listings = Array.from(autopartsMap.values());\r\n          console.log(`   \u2705 [Provider Plugin] Grouped into ${listings.length} autoparts with images`);\r\n          console.log(`   \uD83D\uDCCB [Provider Plugin] Returning all fields (no hardcoded filtering)`);\r\n          return listings as GenericServiceListing[];\r\n        }\r\n\r\n        // Standard mapping for non-grouped results\r\n        // Map raw DB rows into a canonical listing object used by FlowWise workflows.\r\n        const listings: GenericServiceListing[] = rows.map((row: any, idx: number) => {\r\n          const out: any = {\r\n            providerId: provider.id,\r\n            providerName: provider.name,\r\n            gardenId: provider.gardenId,\r\n            location: provider.location,\r\n          };\r\n\r\n          // Generic copy of row values with BigInt normalization\r\n          for (const [k, v] of Object.entries(row || {})) out[k] = normalizeBigInt(v);\r\n\r\n          // Canonical field mapping\r\n          for (const [canonical, col] of Object.entries(fieldMap)) {\r\n            out[canonical] = normalizeBigInt((row as any)?.[col]);\r\n          }\r\n\r\n          // Ensure price exists (many workflows expect `price`)\r\n          if (out.price === undefined || out.price === null) {\r\n            const maybePrice = out.Price ?? out.price_usd ?? out.amount ?? out.cost ?? out.sale_price;\r\n            out.price = typeof maybePrice === \"string\" ? parseFloat(maybePrice) : (typeof maybePrice === \"number\" ? maybePrice : 0);\r\n          }\r\n\r\n          // Airline workflow expects flightId/flightNumber/destination/date for label templates\r\n          if (cfg.serviceType === \"airline\") {\r\n            if (!out.flightNumber && out.flight_no) out.flightNumber = out.flight_no;\r\n            if (!out.flightId) out.flightId = `flight-${out.flightNumber || idx}`;\r\n          }\r\n\r\n          // Autoparts workflow expects partName/partNumber/category/etc (best-effort)\r\n          if (cfg.serviceType === \"autoparts\") {\r\n            if (!out.partName && out.part_name) out.partName = out.part_name;\r\n            if (!out.partName && out.title) out.partName = out.title;\r\n          }\r\n\r\n          return out as GenericServiceListing;\r\n        });\r\n\r\n        return listings;\r\n      }\r\n\r\n      throw new Error(`Unknown provider: ${provider.id}`);\r\n  }\r\n}\r\n\r\nexport async function queryServiceProviders(\r\n  providers: ServiceProvider[],\r\n  filters?: { genre?: string; time?: string; tokenSymbol?: string; baseToken?: string; action?: 'BUY' | 'SELL'; [key: string]: any }\r\n): Promise<MovieListing[] | TokenListing[] | GenericServiceListing[]> {\r\n  const allListings: any[] = [];\r\n  \r\n  // Query each provider's external API in parallel\r\n  const providerPromises = providers.map(provider => \r\n    queryProviderAPI(provider, filters).catch(err => {\r\n      console.warn(`\u26A0\uFE0F  Failed to query ${provider.name} API:`, err.message);\r\n      return []; // Return empty array on error\r\n    })\r\n  );\r\n  \r\n  const results = await Promise.all(providerPromises);\r\n  \r\n  // Flatten results\r\n  for (const listings of results) {\r\n    allListings.push(...(listings as any[]));\r\n  }\r\n  \r\n  return allListings;\r\n}\r\n\r\n// Issue certificate to a service provider\r\nexport function issueServiceProviderCertificate(provider: ServiceProviderWithCert): EdenCertificate {\r\n  if (!ROOT_CA) {\r\n    throw new Error(\"ROOT CA not initialized\");\r\n  }\r\n  \r\n  const cert = ROOT_CA.issueCertificate({\r\n    subject: provider.uuid,\r\n    capabilities: [\"SERVICE_PROVIDER\", \"PRICE_QUOTE\", \"RECEIVE_PAYMENT\"],\r\n    constraints: {\r\n      providerId: provider.id,\r\n      providerName: provider.name,\r\n      serviceType: provider.serviceType,\r\n      location: provider.location,\r\n      bond: provider.bond,\r\n      reputation: provider.reputation\r\n    },\r\n    ttlSeconds: 90 * 24 * 60 * 60 // 90 days\r\n  });\r\n  \r\n  CERTIFICATE_REGISTRY.set(provider.uuid, cert);\r\n  provider.certificate = cert;\r\n  \r\n  // CRITICAL: Update provider in ServiceRegistry2 if it exists there\r\n  try {\r\n    const serviceRegistry2 = getServiceRegistry2();\r\n    if (serviceRegistry2.hasProvider(provider.id)) {\r\n      // Update the provider with the new certificate\r\n      serviceRegistry2.updateProvider(provider);\r\n      console.log(`\uD83D\uDCDC [ServiceRegistry2] Updated provider ${provider.name} with certificate`);\r\n    }\r\n  } catch (err: any) {\r\n    // ServiceRegistry2 not initialized, that's okay - we'll continue with old system\r\n    if (!err.message.includes('not initialized')) {\r\n      console.warn(`\u26A0\uFE0F  [ServiceRegistry2] Failed to update provider with certificate: ${err.message}`);\r\n    }\r\n  }\r\n  \r\n  console.log(`\uD83D\uDCDC Certificate issued to ${provider.name}: ${provider.uuid}`);\r\n  console.log(`   Capabilities: ${cert.capabilities.join(\", \")}`);\r\n  \r\n  broadcastEvent({\r\n    type: \"certificate_issued\",\r\n    component: \"root-ca\",\r\n    message: `Certificate issued to ${provider.name}`,\r\n    timestamp: Date.now(),\r\n    data: {\r\n      subject: cert.subject,\r\n      issuer: cert.issuer,\r\n      capabilities: cert.capabilities,\r\n      expiresAt: cert.expiresAt\r\n    }\r\n  });\r\n  \r\n  return cert;\r\n}\r\n\r\n"],
  "mappings": "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",
  "names": ["autopart", "listings"]
}
