{
  "version": 3,
  "sources": ["../../src/ledger.ts"],
  "sourcesContent": ["/**\r\n * Ledger Module\r\n * Handles ledger entry management, payment processing, and settlement\r\n */\r\n\r\nimport * as crypto from \"crypto\";\r\nimport * as https from \"https\";\r\nimport * as http from \"http\";\r\nimport type { TransactionSnapshot, LedgerEntry, Cashier, User } from \"./types\";\r\nimport { LEDGER, ROOT_CA_SERVICE_REGISTRY, PROVIDER_WEBHOOKS } from \"./state\";\r\nimport { LEDGER_SETTLEMENT_STREAM, ROOT_CA_FEE, INDEXER_FEE } from \"./constants\";\r\nimport { processWalletIntent, getWalletBalance } from \"./wallet\";\r\n\r\n// Dependencies that need to be injected\r\nlet broadcastEvent: (event: any) => void;\r\nlet redis: any; // InMemoryRedisServer instance\r\nlet ensureRedisConnection: () => Promise<void>;\r\nlet SKIP_REDIS: boolean;\r\n\r\n// Cashier instance\r\nlet CASHIER: Cashier;\r\n\r\n/**\r\n * Initialize ledger module with dependencies\r\n */\r\nexport function initializeLedger(\r\n  broadcastFn: (event: any) => void,\r\n  redisInstance: any,\r\n  ensureRedisFn: () => Promise<void>,\r\n  skipRedis: boolean,\r\n  cashier: Cashier\r\n): void {\r\n  broadcastEvent = broadcastFn;\r\n  redis = redisInstance;\r\n  ensureRedisConnection = ensureRedisFn;\r\n  SKIP_REDIS = skipRedis;\r\n  CASHIER = cashier;\r\n  console.log(`\u2705 [Ledger] Initialized with broadcastEvent: ${typeof broadcastEvent === 'function' ? 'OK' : 'MISSING'}`);\r\n}\r\n\r\n/**\r\n * Get cashier status (for API endpoints)\r\n */\r\nexport function getCashierStatus(): Cashier {\r\n  if (!CASHIER) {\r\n    throw new Error(\"Ledger module not initialized. Call initializeLedger() first.\");\r\n  }\r\n  // CRITICAL: Return the actual CASHIER object, not a copy, so updates persist\r\n  // This ensures processedCount and totalProcessed updates are reflected\r\n  return CASHIER;\r\n}\r\n\r\n/**\r\n * Add a ledger entry\r\n */\r\nexport function addLedgerEntry(\r\n  snapshot: TransactionSnapshot,\r\n  serviceType: string,\r\n  iGasCost: number,\r\n  payerId: string,\r\n  merchantName: string, // Provider name (e.g., \"AMC Theatres\", \"Airline Provider\", etc.)\r\n  providerUuid: string, // Service provider UUID for certificate issuance\r\n  bookingDetails?: Record<string, any> // Generic booking details - service-type agnostic\r\n): LedgerEntry {\r\n  // payerId should be the email address (same as payer)\r\n  if (!providerUuid) {\r\n    console.error(`\u274C Provider UUID is missing for merchant: ${merchantName}`);\r\n  }\r\n  \r\n  if (!CASHIER) {\r\n    throw new Error(\"Ledger module not initialized. Call initializeLedger() first.\");\r\n  }\r\n  \r\n  // CRITICAL: Ensure amount is set (use bookingDetails fields if snapshot.amount is missing/zero)\r\n  // Priority: snapshot.amount > bookingDetails fields (price, totalAmount, baseAmount) > 0 (but 0 is invalid)\r\n  // For DEX trades: bookingDetails has baseAmount/totalAmount, not price\r\n  // IMPORTANT: For DEX, we want to use totalAmount (includes fees) for entry.amount, but baseAmount for display\r\n  let entryAmount = snapshot.amount && snapshot.amount > 0 \r\n    ? snapshot.amount \r\n    : (bookingDetails?.totalAmount && bookingDetails.totalAmount > 0\r\n        ? bookingDetails.totalAmount  // For DEX: totalAmount includes fees, use this for entry.amount\r\n        : (bookingDetails?.price && bookingDetails.price > 0 \r\n            ? bookingDetails.price \r\n            : (bookingDetails?.baseAmount && bookingDetails.baseAmount > 0\r\n                ? bookingDetails.baseAmount\r\n                : 0)));\r\n  \r\n  if (!entryAmount || entryAmount === 0) {\r\n    console.error(`\u274C [Ledger] CRITICAL ERROR: Ledger entry amount is ${entryAmount}!`);\r\n    console.error(`\u274C [Ledger] snapshot.amount: ${snapshot.amount}`);\r\n    console.error(`\u274C [Ledger] bookingDetails?.price: ${bookingDetails?.price}`);\r\n    console.error(`\u274C [Ledger] bookingDetails?.baseAmount: ${bookingDetails?.baseAmount}`);\r\n    console.error(`\u274C [Ledger] bookingDetails?.totalAmount: ${bookingDetails?.totalAmount}`);\r\n    console.error(`\u274C [Ledger] serviceType: ${serviceType}`);\r\n    console.error(`\u274C [Ledger] Full bookingDetails:`, JSON.stringify(bookingDetails, null, 2));\r\n    console.error(`\u274C [Ledger] Full snapshot:`, JSON.stringify(snapshot, null, 2));\r\n    console.error(`\u274C [Ledger] This will cause payment to fail!`);\r\n    // Don't create entry with invalid amount - throw error instead\r\n    throw new Error(`Cannot create ledger entry: amount is ${entryAmount}. Snapshot amount: ${snapshot.amount}, bookingDetails: ${JSON.stringify(bookingDetails)}`);\r\n  }\r\n  \r\n  console.log(`\uD83D\uDCB0 [Ledger] Using amount: ${entryAmount} (from snapshot: ${snapshot.amount}, bookingDetails totalAmount: ${bookingDetails?.totalAmount}, baseAmount: ${bookingDetails?.baseAmount}, price: ${bookingDetails?.price})`);\r\n  console.log(`\uD83D\uDCB0 [Ledger] For DEX trades: entry.amount=${entryAmount} (totalAmount with fees), bookingDetails.baseAmount=${bookingDetails?.baseAmount} (for display)`);\r\n\r\n  // CRITICAL: Ensure all required fields are present\r\n  if (!snapshot.txId) {\r\n    console.warn(`\u26A0\uFE0F [Ledger] Warning: snapshot.txId is missing, generating one`);\r\n  }\r\n  \r\n  // CRITICAL: Always use payerId (user email) as the primary source for payer email\r\n  // Priority: payerId (explicitly passed) > snapshot.payer > fallback\r\n  const payerEmail = payerId || snapshot.payer || 'unknown@example.com';\r\n  \r\n  if (!snapshot.payer && !payerId) {\r\n    console.warn(`\u26A0\uFE0F [Ledger] Warning: Both snapshot.payer and payerId are missing, using fallback: ${payerEmail}`);\r\n  } else if (snapshot.payer !== payerEmail) {\r\n    console.log(`\uD83D\uDCE7 [Ledger] Using payerId (${payerEmail}) instead of snapshot.payer (${snapshot.payer})`);\r\n  }\r\n\r\n  const entry: LedgerEntry = {\r\n    entryId: crypto.randomUUID(),\r\n    txId: snapshot.txId || `tx_${Date.now()}`,\r\n    timestamp: snapshot.blockTime || Date.now(),\r\n    payer: payerEmail, // Email address - always use payerId (user email from server)\r\n    payerId: payerEmail, // Email address (same as payer)\r\n    merchant: merchantName, // Provider name (e.g., \"AMC Theatres\", \"MovieCom\", \"Cinemark\")\r\n    providerUuid: providerUuid || 'MISSING-UUID', // Service provider UUID for certificate issuance\r\n    serviceType: serviceType,\r\n    amount: entryAmount,\r\n    iGasCost: iGasCost,\r\n    fees: snapshot.feeSplit || {},\r\n    status: 'pending',\r\n    cashierId: CASHIER.id,\r\n    bookingDetails: bookingDetails,\r\n  };\r\n  \r\n  console.log(`\uD83D\uDCDD [Ledger] \u2705 Ledger entry created successfully:`);\r\n  console.log(`\uD83D\uDCDD [Ledger]   entryId: ${entry.entryId}`);\r\n  console.log(`\uD83D\uDCDD [Ledger]   providerUuid: ${entry.providerUuid}`);\r\n  console.log(`\uD83D\uDCDD [Ledger]   amount: ${entry.amount}`);\r\n  console.log(`\uD83D\uDCDD [Ledger]   txId: ${entry.txId}`);\r\n  console.log(`\uD83D\uDCDD [Ledger]   payer: ${entry.payer}`);\r\n  console.log(`\uD83D\uDCDD [Ledger]   status: ${entry.status}`);\r\n\r\n  // Push ledger entry to local ledger (for immediate access)\r\n  LEDGER.push(entry);\r\n  \r\n  // CRITICAL: Persist ledger entry IMMEDIATELY (ROOT CA operation - no debounce)\r\n  // ROOT CA ledger entries must be saved synchronously - Eden must have it before Angular\r\n  if (redis) {\r\n    console.log(`\uD83D\uDCBE [Ledger] \uD83D\uDD10 ROOT CA: Saving ${LEDGER.length} ledger entries IMMEDIATELY (including new ${entry.serviceType} entry: ${entry.entryId})`);\r\n    try {\r\n      redis.saveLedgerEntries(LEDGER);\r\n      console.log(`\uD83D\uDCBE [Ledger] \u2705 ROOT CA: Ledger entry ${entry.entryId} persisted IMMEDIATELY to disk`);\r\n    } catch (err: any) {\r\n      console.error(`\u274C [Ledger] CRITICAL: Failed to save ledger entry IMMEDIATELY: ${err.message}`);\r\n      console.error(`\u274C [Ledger] Stack:`, err.stack);\r\n    }\r\n  } else {\r\n    console.error(`\u274C [Ledger] CRITICAL: Redis instance not available! Cannot persist ledger entry: ${entry.entryId}`);\r\n  }\r\n  \r\n  // ARCHITECTURAL PATTERN: Ledger Push + Settlement Pull\r\n  // Indexers EXECUTE transactions but never SETTLE them\r\n  // Push ledger entry to ROOT CA Redis Stream for settlement\r\n  pushLedgerEntryToSettlementStream(entry).catch(err => {\r\n    console.error(`\u26A0\uFE0F  Failed to push ledger entry to settlement stream:`, err.message);\r\n    // Continue execution - settlement will retry\r\n  });\r\n  \r\n  // CRITICAL: Broadcast ledger entry added event to Angular\r\n  if (!broadcastEvent) {\r\n    console.error(`\u274C [Ledger] broadcastEvent not initialized! Cannot send ledger_entry_added event`);\r\n  } else {\r\n    const ledgerEvent = {\r\n      type: \"ledger_entry_added\",\r\n      component: \"ledger\",\r\n      message: `Ledger entry created: ${entry.entryId}`,\r\n      timestamp: Date.now(),\r\n      data: { entry }\r\n    };\r\n    console.log(`\uD83D\uDCE1 [Broadcast] Sending ledger_entry_added event: ${entry.entryId} for ${entry.merchant}`);\r\n    broadcastEvent(ledgerEvent);\r\n  }\r\n\r\n  return entry;\r\n}\r\n\r\n/**\r\n * Push ledger entry to ROOT CA settlement stream\r\n */\r\nexport async function pushLedgerEntryToSettlementStream(entry: LedgerEntry): Promise<void> {\r\n  // CRITICAL: Calculate fees and record in Accountant Service BEFORE checking Redis\r\n  // This ensures fees are tracked even when Redis is disabled\r\n  const iGas = entry.iGasCost;\r\n  const iTax = entry.bookingDetails?.iTax || 0;\r\n  \r\n  // Calculate fee distribution (prefer real economic feeSplit from ledger entry; fall back to iGas-derived)\r\n  // NOTE: ledgerEntry.fees is typically populated from snapshot.feeSplit with keys:\r\n  // { indexer, cashier, provider, eden }\r\n  const rootCAFee = (entry.fees as any)?.eden ?? (entry.fees as any)?.rootCA ?? (iGas * ROOT_CA_FEE);\r\n  const indexerFee = (entry.fees as any)?.indexer ?? (iGas * INDEXER_FEE);\r\n  const providerFee = (entry.fees as any)?.provider ?? 0;\r\n  const cashierFee = (entry.fees as any)?.cashier ?? 0;\r\n  \r\n  // Record fee payment in Accountant Service (always, regardless of Redis status)\r\n  // CRITICAL: Record fees even if iGas is 0, to track all transactions\r\n  try {\r\n    const { recordFeePayment } = await import(\"./accountant\");\r\n    recordFeePayment(\r\n      entry.serviceType,\r\n      iGas,\r\n      iTax,\r\n      rootCAFee,\r\n      indexerFee,\r\n      providerFee,\r\n      cashierFee\r\n    );\r\n    console.log(`\uD83D\uDCCA [Accountant] \u2705 Recorded fees for ${entry.serviceType}: iGas=${iGas.toFixed(6)}, iTax=${iTax.toFixed(6)}, ROOT CA=${rootCAFee.toFixed(6)}, Indexer=${indexerFee.toFixed(6)}`);\r\n    console.log(`\uD83D\uDCCA [Accountant] Entry ID: ${entry.entryId}, Amount: ${entry.amount}, Status: ${entry.status}`);\r\n  } catch (err: any) {\r\n    console.error(`\u274C [Settlement] Failed to record fee payment in Accountant: ${err.message}`);\r\n    console.error(`\u274C [Settlement] Error stack:`, err.stack);\r\n  }\r\n  \r\n  // Now handle Redis settlement stream (if enabled)\r\n  if (SKIP_REDIS || !redis.isOpen) {\r\n    console.log(`\uD83D\uDCE4 [Settlement] Ledger entry ${entry.entryId} queued (Redis disabled)`);\r\n    return;\r\n  }\r\n\r\n  try {\r\n    await ensureRedisConnection();\r\n    \r\n    // Extract garden ID from provider (if available)\r\n    const provider = ROOT_CA_SERVICE_REGISTRY.find(p => p.uuid === entry.providerUuid);\r\n    const gardenId = provider?.gardenId || 'unknown';\r\n    \r\n    const settlementPayload = {\r\n      entryId: entry.entryId,\r\n      txId: entry.txId,\r\n      timestamp: entry.timestamp.toString(),\r\n      payer: entry.payer,\r\n      payerId: entry.payerId,\r\n      merchant: entry.merchant,\r\n      providerUuid: entry.providerUuid,\r\n      gardenId: gardenId,\r\n      serviceType: entry.serviceType,\r\n      amount: entry.amount.toString(),\r\n      iGas: iGas.toString(),\r\n      iTax: iTax.toString(),\r\n      fees: JSON.stringify({\r\n        rootCA: rootCAFee,\r\n        indexer: indexerFee,\r\n        ...entry.fees\r\n      }),\r\n      status: entry.status,\r\n      cashierId: entry.cashierId,\r\n      bookingDetails: entry.bookingDetails ? JSON.stringify(entry.bookingDetails) : '',\r\n    };\r\n    \r\n    await redis.xAdd(LEDGER_SETTLEMENT_STREAM, \"*\", settlementPayload);\r\n    \r\n    console.log(`\uD83D\uDCE4 [Settlement] Pushed ledger entry ${entry.entryId} to ROOT CA settlement stream`);\r\n    console.log(`   iGas: ${iGas}, iTax: ${iTax}, ROOT CA Fee: ${rootCAFee}, Indexer Fee: ${indexerFee}`);\r\n    \r\n    broadcastEvent({\r\n      type: \"ledger_entry_pushed\",\r\n      component: \"settlement\",\r\n      message: `Ledger entry pushed to settlement stream: ${entry.entryId}`,\r\n      timestamp: Date.now(),\r\n      data: { \r\n        entryId: entry.entryId, \r\n        iGas, \r\n        iTax, \r\n        fees: settlementPayload.fees,\r\n        rootCAFee,\r\n        indexerFee,\r\n        indexerId: gardenId // Legacy field (will be renamed to gardenId in future)\r\n      }\r\n    });\r\n  } catch (err: any) {\r\n    console.error(`\u274C Failed to push ledger entry to settlement stream:`, err.message);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Process payment through cashier\r\n */\r\nexport async function processPayment(cashier: Cashier, entry: LedgerEntry, user: User): Promise<boolean> {\r\n  // NO AUTO-GRANT - User must have balance from Stripe or other credits\r\n  \r\n  console.log(`   \uD83D\uDCB0 [Ledger] ========================================`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] \uD83D\uDCB3 processPayment FUNCTION CALLED`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Entry ID: ${entry.entryId}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Entry Amount: ${entry.amount}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Entry Status (before): ${entry.status}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] User Email: ${user.email}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Cashier ID: ${cashier.id}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Cashier processedCount (before): ${cashier.processedCount}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Cashier totalProcessed (before): ${cashier.totalProcessed}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] ========================================`);\r\n  \r\n  // CRITICAL: Validate entry has an amount\r\n  if (!entry.amount || entry.amount <= 0) {\r\n    console.error(`   \u274C [Ledger] Cannot process payment: entry ${entry.entryId} has invalid amount: ${entry.amount}`);\r\n    entry.status = 'failed';\r\n    broadcastEvent({\r\n      type: \"cashier_payment_failed\",\r\n      component: \"cashier\",\r\n      message: `Payment failed: Invalid amount (${entry.amount})`,\r\n      timestamp: Date.now(),\r\n      data: { \r\n        entry, \r\n        cashier, \r\n        error: `Invalid amount: ${entry.amount}`,\r\n        requiredAmount: entry.amount\r\n      }\r\n    });\r\n    return false;\r\n  }\r\n  \r\n  console.log(`   \uD83D\uDCB0 [Ledger] Step 1: Amount validation passed`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Validated amount: ${entry.amount} \uD83C\uDF4E APPLES`);\r\n\r\n  // Get current balance before creating intent\r\n  const { getWalletBalance } = await import(\"./wallet\");\r\n  const balanceBeforeIntent = await getWalletBalance(user.email);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Step 1.5: Current wallet balance: ${balanceBeforeIntent} \uD83C\uDF4E APPLES`);\r\n\r\n  // EdenCore submits intent to Wallet Service\r\n  // Wallet Service decides and updates balance (single source of truth)\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Step 2: Calling processWalletIntent`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Intent details:`, {\r\n    intent: \"DEBIT\",\r\n    email: user.email,\r\n    amount: entry.amount,\r\n    txId: entry.txId,\r\n    entryId: entry.entryId,\r\n    reason: `Payment to ${entry.merchant} (${entry.serviceType})`\r\n  });\r\n  \r\n  const walletResult = await processWalletIntent({\r\n    intent: \"DEBIT\",\r\n    email: user.email,\r\n    amount: entry.amount,\r\n    txId: entry.txId,\r\n    entryId: entry.entryId,\r\n    reason: `Payment to ${entry.merchant} (${entry.serviceType})`,\r\n    metadata: {\r\n      merchant: entry.merchant,\r\n      serviceType: entry.serviceType,\r\n      cashierId: cashier.id,\r\n    }\r\n  });\r\n  \r\n  console.log(`   \uD83D\uDCB0 [Ledger] Step 2.5: Wallet intent completed`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Wallet result:`, {\r\n    success: walletResult.success,\r\n    balance: walletResult.balance,\r\n    previousBalance: walletResult.previousBalance,\r\n    error: walletResult.error\r\n  });\r\n  \r\n  // Verify balance changed\r\n  const balanceAfterIntent = await getWalletBalance(user.email);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Balance verification:`, {\r\n    before: balanceBeforeIntent,\r\n    after: balanceAfterIntent,\r\n    expectedChange: entry.amount,\r\n    actualChange: balanceBeforeIntent - balanceAfterIntent,\r\n    matches: (balanceBeforeIntent - balanceAfterIntent) === entry.amount\r\n  });\r\n  \r\n  if (!walletResult.success) {\r\n    console.error(`   \u274C [Ledger] Wallet intent failed: ${walletResult.error}`);\r\n    entry.status = 'failed';\r\n    const walletBalance = await getWalletBalance(user.email);\r\n    broadcastEvent({\r\n      type: \"cashier_payment_failed\",\r\n      component: \"cashier\",\r\n      message: `Payment failed: ${walletResult.error}`,\r\n      timestamp: Date.now(),\r\n      data: { \r\n        entry, \r\n        cashier, \r\n        error: walletResult.error,\r\n        walletBalance,\r\n        userBalance: user.balance,\r\n        requiredAmount: entry.amount\r\n      }\r\n    });\r\n    return false;\r\n  }\r\n\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Step 3: Wallet intent succeeded`);\r\n  \r\n  // Update user balance for backward compatibility (wallet is source of truth)\r\n  user.balance = walletResult.balance;\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Updated user balance: ${user.balance}`);\r\n  \r\n  // CRITICAL: Update the actual CASHIER object (not just the parameter copy)\r\n  // The cashier parameter might be a copy from getCashierStatus(), so we need to update CASHIER directly\r\n  if (!CASHIER) {\r\n    throw new Error(\"CASHIER not initialized\");\r\n  }\r\n  \r\n  console.log(`   \uD83D\uDCB0 [Ledger] Step 4: Updating CASHIER object`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] CASHIER processedCount (before): ${CASHIER.processedCount}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] CASHIER totalProcessed (before): ${CASHIER.totalProcessed}`);\r\n  \r\n  CASHIER.processedCount++;\r\n  CASHIER.totalProcessed += entry.amount;\r\n  \r\n  console.log(`   \uD83D\uDCB0 [Ledger] CASHIER processedCount (after): ${CASHIER.processedCount}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] CASHIER totalProcessed (after): ${CASHIER.totalProcessed}`);\r\n  \r\n  // Also update the parameter for backward compatibility (in case it's used elsewhere)\r\n  cashier.processedCount = CASHIER.processedCount;\r\n  cashier.totalProcessed = CASHIER.totalProcessed;\r\n  \r\n  console.log(`   \uD83D\uDCB0 [Ledger] Step 5: Updating entry status to 'processed'`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Entry status (before update): ${entry.status}`);\r\n  entry.status = 'processed';\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Entry status (after update): ${entry.status}`);\r\n  \r\n  // CRITICAL: Persist ledger entry IMMEDIATELY after payment processing (ROOT CA operation)\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Step 6: Persisting ledger entry IMMEDIATELY (ROOT CA)`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Redis available: ${!!redis}`);\r\n  if (redis) {\r\n    redis.saveLedgerEntries(LEDGER);\r\n    console.log(`   \uD83D\uDCBE [Ledger] \u2705 ROOT CA: Persisted ledger entry ${entry.entryId} IMMEDIATELY after payment processing`);\r\n    // Verify the entry in LEDGER array\r\n    const persistedEntry = LEDGER.find(e => e.entryId === entry.entryId);\r\n    console.log(`   \uD83D\uDCB0 [Ledger] Verification - Entry in LEDGER array:`, persistedEntry ? {\r\n      entryId: persistedEntry.entryId,\r\n      status: persistedEntry.status,\r\n      amount: persistedEntry.amount\r\n    } : 'NOT FOUND');\r\n  } else {\r\n    console.error(`   \u274C [Ledger] CRITICAL: Redis not available! Cannot persist ledger entry!`);\r\n  }\r\n\r\n  // CRITICAL: Broadcast payment processed event to Angular\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Step 7: Broadcasting payment processed event`);\r\n  if (!broadcastEvent) {\r\n    console.error(`   \u274C [Ledger] broadcastEvent not initialized! Cannot send cashier_payment_processed event`);\r\n  } else {\r\n    const paymentEvent = {\r\n      type: \"cashier_payment_processed\",\r\n      component: \"cashier\",\r\n      message: `${cashier.name} processed payment: ${entry.amount} \uD83C\uDF4E APPLES`,\r\n      timestamp: Date.now(),\r\n      data: { entry, cashier, userBalance: walletResult.balance, walletService: \"wallet-service-001\" }\r\n    };\r\n    console.log(`   \uD83D\uDCE1 [Broadcast] Sending cashier_payment_processed event: ${cashier.name} processed ${entry.amount} \uD83C\uDF4E APPLES`);\r\n    broadcastEvent(paymentEvent);\r\n  }\r\n\r\n  console.log(`   \uD83D\uDCB0 [Ledger] ========================================`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] \u2705 processPayment COMPLETED SUCCESSFULLY`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] Entry Status: ${entry.status}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] CASHIER processedCount: ${CASHIER.processedCount}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] CASHIER totalProcessed: ${CASHIER.totalProcessed}`);\r\n  console.log(`   \uD83D\uDCB0 [Ledger] ========================================`);\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Complete a booking\r\n */\r\nexport function completeBooking(entry: LedgerEntry) {\r\n  entry.status = 'completed';\r\n  \r\n  broadcastEvent({\r\n    type: \"ledger_booking_completed\",\r\n    component: \"ledger\",\r\n    message: `Booking completed: ${entry.entryId}`,\r\n    timestamp: Date.now(),\r\n    data: { entry }\r\n  });\r\n}\r\n\r\n/**\r\n * Get ledger entries\r\n */\r\nexport function getLedgerEntries(payerEmail?: string): LedgerEntry[] {\r\n  let entries: LedgerEntry[];\r\n  if (payerEmail) {\r\n    entries = LEDGER.filter(entry => entry.payer === payerEmail);\r\n  } else {\r\n    entries = [...LEDGER];\r\n  }\r\n  \r\n  // CRITICAL: Normalize numeric fields (iGasCost, amount, timestamp) to ensure they're numbers, not strings\r\n  // This fixes issues when data is loaded from persistence where JSON might have stored them as strings\r\n  return entries.map(entry => ({\r\n    ...entry,\r\n    iGasCost: typeof entry.iGasCost === 'string' ? parseFloat(entry.iGasCost) : (entry.iGasCost || 0),\r\n    amount: typeof entry.amount === 'string' ? parseFloat(entry.amount) : (entry.amount || 0),\r\n    timestamp: typeof entry.timestamp === 'string' ? parseInt(entry.timestamp) : (entry.timestamp || Date.now()),\r\n    // Normalize fees object if it exists\r\n    fees: entry.fees ? Object.fromEntries(\r\n      Object.entries(entry.fees).map(([key, value]) => [\r\n        key,\r\n        typeof value === 'string' ? parseFloat(value) : (value || 0)\r\n      ])\r\n    ) : {}\r\n  }));\r\n}\r\n\r\n/**\r\n * Get transactions by payer\r\n */\r\nexport function getTransactionByPayer(payerEmail: string): LedgerEntry[] {\r\n  return LEDGER.filter(entry => entry.payer === payerEmail && entry.status === 'completed');\r\n}\r\n\r\n/**\r\n * Get transaction by snapshot ID\r\n */\r\nexport function getTransactionBySnapshot(snapshotId: string): LedgerEntry | null {\r\n  return LEDGER.find(entry => entry.txId === snapshotId) || null;\r\n}\r\n\r\n/**\r\n * Get latest snapshot for a provider\r\n */\r\nexport function getLatestSnapshot(providerId: string): LedgerEntry | null {\r\n  const providerEntries = LEDGER.filter(entry => \r\n    entry.merchant === providerId || entry.providerUuid === providerId\r\n  );\r\n  if (providerEntries.length === 0) return null;\r\n  \r\n  // Return most recent completed transaction\r\n  return providerEntries\r\n    .filter(entry => entry.status === 'completed')\r\n    .sort((a, b) => b.timestamp - a.timestamp)[0] || null;\r\n}\r\n\r\n/**\r\n * Deliver webhook to service provider\r\n */\r\nexport async function deliverWebhook(providerId: string, snapshot: TransactionSnapshot, ledgerEntry: LedgerEntry): Promise<void> {\r\n  const webhook = PROVIDER_WEBHOOKS.get(providerId);\r\n  if (!webhook) {\r\n    return; // No webhook registered\r\n  }\r\n  \r\n  console.log(`\uD83D\uDCE4 [Service Provider] Webhook Delivery Attempt: ${providerId} \u2192 ${webhook.webhookUrl} (TX: ${snapshot.txId.substring(0, 8)}...)`);\r\n  \r\n  // Broadcast webhook delivery attempt\r\n  broadcastEvent({\r\n    type: \"provider_webhook_attempt\",\r\n    component: \"service_provider\",\r\n    message: `Webhook Delivery Attempt: ${providerId}`,\r\n    timestamp: Date.now(),\r\n    data: {\r\n      providerId,\r\n      txId: snapshot.txId,\r\n      webhookUrl: webhook.webhookUrl\r\n    }\r\n  });\r\n  \r\n  const payload = JSON.stringify({\r\n    event: 'tx-finalized',\r\n    snapshot: {\r\n      chainId: snapshot.chainId,\r\n      txId: snapshot.txId,\r\n      slot: snapshot.slot,\r\n      blockTime: snapshot.blockTime,\r\n      payer: snapshot.payer,\r\n      merchant: snapshot.merchant,\r\n      amount: snapshot.amount,\r\n      feeSplit: snapshot.feeSplit,\r\n    },\r\n    ledger: {\r\n      entryId: ledgerEntry.entryId,\r\n      status: ledgerEntry.status,\r\n      serviceType: ledgerEntry.serviceType,\r\n      bookingDetails: ledgerEntry.bookingDetails,\r\n    },\r\n    timestamp: Date.now(),\r\n  });\r\n  \r\n  try {\r\n    const parsedUrl = new URL(webhook.webhookUrl);\r\n    const options = {\r\n      hostname: parsedUrl.hostname,\r\n      port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),\r\n      path: parsedUrl.pathname + parsedUrl.search,\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Content-Length': payload.length,\r\n      },\r\n    };\r\n    \r\n    const client = parsedUrl.protocol === 'https:' ? https : http;\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      const req = client.request(options, (res) => {\r\n        let responseData = '';\r\n        res.on('data', (chunk) => { responseData += chunk; });\r\n        res.on('end', () => {\r\n          if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\r\n            webhook.failureCount = 0;\r\n            console.log(`\u2705 [Service Provider] Webhook delivered: ${providerId} (${res.statusCode})`);\r\n            broadcastEvent({\r\n              type: \"provider_webhook_delivered\",\r\n              component: \"service_provider\",\r\n              message: `Webhook delivered: ${providerId}`,\r\n              timestamp: Date.now(),\r\n              data: { providerId, statusCode: res.statusCode }\r\n            });\r\n            resolve();\r\n          } else {\r\n            webhook.failureCount++;\r\n            console.warn(`\u26A0\uFE0F  [Service Provider] Webhook failed: ${providerId} (${res.statusCode})`);\r\n            reject(new Error(`Webhook delivery failed: ${res.statusCode}`));\r\n          }\r\n        });\r\n      });\r\n      \r\n      req.on('error', (err) => {\r\n        webhook.failureCount++;\r\n        console.error(`\u274C [Service Provider] Webhook error: ${providerId}`, err.message);\r\n        reject(err);\r\n      });\r\n      \r\n      req.write(payload);\r\n      req.end();\r\n    });\r\n  } catch (err: any) {\r\n    webhook.failureCount++;\r\n    console.error(`\u274C [Service Provider] Webhook delivery failed: ${providerId}`, err.message);\r\n    throw err;\r\n  }\r\n}\r\n\r\n"],
  "mappings": "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",
  "names": ["getWalletBalance"]
}
