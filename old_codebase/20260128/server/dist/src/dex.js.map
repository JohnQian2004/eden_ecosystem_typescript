{
  "version": 3,
  "sources": ["../../src/dex.ts"],
  "sourcesContent": ["/**\r\n * DEX Module\r\n * Handles DEX pool initialization and trading\r\n */\r\n\r\nimport * as crypto from \"crypto\";\r\nimport type { TokenPool, DEXTrade } from \"./types\";\r\nimport { TOKEN_GARDENS, DEX_POOLS, ROOT_CA_SERVICE_REGISTRY, rootCALiquidity, addRootCALiquidity } from \"./state\";\r\nimport { PRICE_IMPACT_PER_TRADE, ITAX_RATE, ITAX_DISTRIBUTION, LLM_BASE_COST, ROUTING_COST_PER_PROVIDER, REASONING_COST_MULTIPLIER } from \"./constants\";\r\n\r\n// Dependencies that need to be injected\r\nlet broadcastEvent: (event: any) => void = () => {};\r\n\r\nfunction normalizePoolId(poolId: string): string {\r\n  return (poolId || \"\").trim().toLowerCase();\r\n}\r\n\r\nfunction parseTokenSymbolFromPoolId(poolId: string): string | null {\r\n  // Expected formats:\r\n  // - pool-solana-token-1 => \"TOKEN\"\r\n  // - pool-solana-token-2 => \"TOKEN\"\r\n  // - pool-solana-tokena => \"TOKEN\" (legacy support)\r\n  // All pools now use \"TOKEN\" as the symbol (changed from TOKENA, TOKENB, etc.)\r\n  const normalized = normalizePoolId(poolId);\r\n  if (!normalized.startsWith(\"pool-solana-\")) return null;\r\n  const suffix = normalized.slice(\"pool-solana-\".length);\r\n  if (!suffix) return null;\r\n  \r\n  // If it starts with \"token\" (case-insensitive), return \"TOKEN\"\r\n  const cleaned = suffix.replace(/[^a-z0-9_-]/g, \"\").toLowerCase();\r\n  if (!cleaned) return null;\r\n  \r\n  // Check if it starts with \"token\" (handles \"token-1\", \"token1\", \"tokena\", etc.)\r\n  if (cleaned.startsWith(\"token\")) {\r\n    return \"TOKEN\"; // All pools use \"TOKEN\" now\r\n  }\r\n  \r\n  // Legacy support: if it's just a letter/number, assume it's a token suffix\r\n  // But still return \"TOKEN\" for consistency\r\n  return \"TOKEN\";\r\n}\r\n\r\nfunction createSyntheticPool(poolId: string): TokenPool | null {\r\n  const tokenSymbol = parseTokenSymbolFromPoolId(poolId);\r\n  if (!tokenSymbol) return null;\r\n\r\n  const gardenId = TOKEN_GARDENS[0]?.id || \"T1\";\r\n  const tokenLetter = tokenSymbol.replace(/^TOKEN/, \"\") || \"X\";\r\n  const tokenName = `Token ${tokenLetter}`;\r\n\r\n  const pool: TokenPool = {\r\n    poolId: normalizePoolId(poolId),\r\n    tokenSymbol,\r\n    tokenName,\r\n    baseToken: \"SOL\",\r\n    poolLiquidity: 100,\r\n    tokenReserve: 100000,\r\n    baseReserve: 100,\r\n    price: 0.001,\r\n    bond: 5000,\r\n    gardenId,\r\n    createdAt: Date.now(),\r\n    totalVolume: 0,\r\n    totalTrades: 0,\r\n  };\r\n\r\n  return pool;\r\n}\r\n\r\n/**\r\n * Initialize DEX module with dependencies\r\n */\r\nexport function initializeDEX(broadcastFn: (event: any) => void): void {\r\n  broadcastEvent = broadcastFn;\r\n}\r\n\r\n/**\r\n * Initialize DEX pools, assigning them to token gardens\r\n */\r\nexport function initializeDEXPools(): void {\r\n  // Initialize DEX pools, assigning them to token gardens\r\n  // Each token garden can provide multiple pools\r\n  for (let i = 0; i < TOKEN_GARDENS.length; i++) {\r\n    const tokenGarden = TOKEN_GARDENS[i];\r\n    if (!tokenGarden) continue;\r\n    \r\n    // Create pools for this token garden\r\n    // All token gardens use TOKEN/SOL format\r\n    const tokenSymbol = 'TOKEN';\r\n    const tokenName = `Token ${i + 1}`;\r\n    const poolId = `pool-solana-token-${i + 1}`;\r\n    \r\n    const pool: TokenPool = {\r\n      poolId: poolId,\r\n      tokenSymbol: tokenSymbol,\r\n      tokenName: tokenName,\r\n      baseToken: \"SOL\",\r\n      poolLiquidity: 100 - (i * 10), // Decreasing liquidity for variety: 100, 90, 80...\r\n      tokenReserve: 100000 - (i * 10000), // 100k, 90k, 80k...\r\n      baseReserve: 100 - (i * 10), // 100, 90, 80...\r\n      price: 0.001, // 1 Token = 0.001 SOL\r\n      bond: 5000,\r\n      gardenId: tokenGarden.id, // Assign to token garden\r\n      createdAt: Date.now(),\r\n      totalVolume: 0,\r\n      totalTrades: 0,\r\n    };\r\n    DEX_POOLS.set(poolId, pool);\r\n  }\r\n\r\n  console.log(`\uD83C\uDF0A Initialized ${DEX_POOLS.size} DEX pools`);\r\n  console.log(`\uD83D\uDCB0 ROOT CA Liquidity Pool: ${rootCALiquidity} SOL`);\r\n  console.log(`\uD83D\uDD37 Token Gardens: ${TOKEN_GARDENS.map(ti => ti.name).join(\", \")}`);\r\n  \r\n  // Display pool assignments and register with liquidity accountant\r\n  for (const [poolId, pool] of DEX_POOLS.entries()) {\r\n    console.log(`   ${pool.tokenSymbol} Pool \u2192 ${pool.gardenId} (${pool.poolLiquidity} SOL liquidity)`);\r\n    \r\n    // Register existing pools with liquidity accountant (if not already registered)\r\n    // Use dynamic import without await (synchronous registration)\r\n    import(\"./liquidityAccountant\").then(({ getLiquidityRecord, registerInitialLiquidity }) => {\r\n      const existing = getLiquidityRecord(poolId);\r\n      if (!existing) {\r\n        // Register pool with current liquidity state\r\n        registerInitialLiquidity(\r\n          poolId,\r\n          pool.tokenSymbol,\r\n          pool.baseToken,\r\n          pool.gardenId,\r\n          pool.baseReserve || pool.poolLiquidity,\r\n          pool.baseReserve || pool.poolLiquidity,\r\n          pool.tokenReserve,\r\n          pool.stripePaymentIntentId\r\n        );\r\n        console.log(`   \uD83D\uDCA7 [LiquidityAccountant] Registered existing pool ${pool.tokenSymbol}/${pool.baseToken}`);\r\n      }\r\n    }).catch((err: any) => {\r\n      console.warn(`   \u26A0\uFE0F  [DEX] Failed to register pool with liquidity accountant: ${err.message}`);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a DEX trade\r\n */\r\nexport function executeDEXTrade(\r\n  poolId: string,\r\n  action: 'BUY' | 'SELL',\r\n  tokenAmount: number,\r\n  userEmail: string\r\n): DEXTrade {\r\n  const requestedPoolId = poolId;\r\n  const normalizedPoolId = normalizePoolId(poolId);\r\n\r\n  // Fast path: exact match\r\n  let pool = DEX_POOLS.get(requestedPoolId) || DEX_POOLS.get(normalizedPoolId);\r\n\r\n  // If missing, try initializing standard pools (no-op if already initialized)\r\n  if (!pool) {\r\n    if (DEX_POOLS.size === 0) {\r\n      console.warn(`\u26A0\uFE0F  [DEX] DEX_POOLS is empty at trade time; attempting to initialize pools...`);\r\n    } else {\r\n      console.warn(`\u26A0\uFE0F  [DEX] Pool \"${requestedPoolId}\" not found; attempting to re-initialize pools and retry lookup...`);\r\n    }\r\n    try {\r\n      initializeDEXPools();\r\n    } catch (err: any) {\r\n      console.warn(`\u26A0\uFE0F  [DEX] initializeDEXPools() failed during trade: ${err?.message || err}`);\r\n    }\r\n    pool = DEX_POOLS.get(requestedPoolId) || DEX_POOLS.get(normalizedPoolId);\r\n  }\r\n\r\n  // If still missing, try case-insensitive match against existing pool objects\r\n  if (!pool && DEX_POOLS.size > 0) {\r\n    const match = Array.from(DEX_POOLS.values()).find(p => normalizePoolId(p.poolId) === normalizedPoolId);\r\n    if (match) pool = match;\r\n  }\r\n\r\n  // Last resort: create a synthetic pool from the requested poolId to avoid runtime failure\r\n  if (!pool) {\r\n    const synthetic = createSyntheticPool(requestedPoolId);\r\n    if (synthetic) {\r\n      DEX_POOLS.set(synthetic.poolId, synthetic);\r\n      pool = synthetic;\r\n      console.warn(\r\n        `\u26A0\uFE0F  [DEX] Pool \"${requestedPoolId}\" was missing; created synthetic pool \"${synthetic.poolId}\" for token ${synthetic.tokenSymbol}.`\r\n      );\r\n    }\r\n  }\r\n\r\n  if (!pool) {\r\n    const available = Array.from(DEX_POOLS.keys()).slice(0, 20).join(\", \");\r\n    throw new Error(\r\n      `Pool ${requestedPoolId} not found (normalized: ${normalizedPoolId}). ` +\r\n      `DEX_POOLS.size=${DEX_POOLS.size}. ` +\r\n      (DEX_POOLS.size ? `Available poolIds (first 20): ${available}` : `No pools are initialized.`)\r\n    );\r\n  }\r\n\r\n  // Step 1: Use ROOT CA liquidity as first liquidity source\r\n  // For BUY: User pays baseToken, gets tokens\r\n  // For SELL: User pays tokens, gets baseToken\r\n  \r\n  let baseAmount: number;\r\n  let newPrice: number;\r\n  \r\n  if (action === 'BUY') {\r\n    // User wants to BUY tokens with baseToken (SOL)\r\n    // Calculate baseToken needed using constant product formula: x * y = k\r\n    // After trade: (baseReserve + baseAmount) * (tokenReserve - tokenAmount) = baseReserve * tokenReserve\r\n    // Solving: baseAmount = (baseReserve * tokenAmount) / (tokenReserve - tokenAmount)\r\n    baseAmount = (pool.baseReserve * tokenAmount) / (pool.tokenReserve - tokenAmount);\r\n    \r\n    // Apply price impact (0.001% = 0.00001)\r\n    const priceImpact = PRICE_IMPACT_PER_TRADE;\r\n    baseAmount = baseAmount * (1 + priceImpact);\r\n    \r\n    // Update pool reserves\r\n    pool.baseReserve += baseAmount;\r\n    pool.tokenReserve -= tokenAmount;\r\n    \r\n    // Calculate new price\r\n    newPrice = pool.baseReserve / pool.tokenReserve;\r\n    pool.price = newPrice;\r\n    \r\n    // Increase pool value by 0.001%\r\n    pool.poolLiquidity *= (1 + PRICE_IMPACT_PER_TRADE);\r\n  } else {\r\n    // SELL: User wants to SELL tokens for baseToken\r\n    // Calculate baseToken received: baseAmount = (baseReserve * tokenAmount) / (tokenReserve + tokenAmount)\r\n    baseAmount = (pool.baseReserve * tokenAmount) / (pool.tokenReserve + tokenAmount);\r\n    \r\n    // Apply price impact\r\n    const priceImpact = PRICE_IMPACT_PER_TRADE;\r\n    baseAmount = baseAmount * (1 - priceImpact);\r\n    \r\n    // Update pool reserves\r\n    pool.baseReserve -= baseAmount;\r\n    pool.tokenReserve += tokenAmount;\r\n    \r\n    // Calculate new price\r\n    newPrice = pool.baseReserve / pool.tokenReserve;\r\n    pool.price = newPrice;\r\n    \r\n    // Increase pool value by 0.001%\r\n    pool.poolLiquidity *= (1 + PRICE_IMPACT_PER_TRADE);\r\n  }\r\n  \r\n  // Step 2: Calculate iTax (0.0005% commission)\r\n  const tradeValue = baseAmount; // Trade value in baseToken\r\n  let iTax = tradeValue * ITAX_RATE;\r\n  \r\n  // Apply Snake provider multiplier if pool provider is Snake\r\n  // DEX pool providers are registered with id like \"dex-pool-{tokenSymbol}\"\r\n  const poolProviderId = `dex-pool-${pool.tokenSymbol.toLowerCase()}`;\r\n  const poolProvider = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === poolProviderId);\r\n  if ((poolProvider as any)?.providerType === 'SNAKE') {\r\n    const snakeITaxMultiplier = (poolProvider as any).iTaxMultiplier || 2.0;\r\n    iTax = iTax * snakeITaxMultiplier;\r\n    console.log(`\uD83D\uDC0D [Snake Provider] Applied iTax multiplier: ${snakeITaxMultiplier}x for pool ${poolId}`);\r\n  }\r\n  \r\n  // Step 3: Distribute iTax (WIN-WIN-WIN)\r\n  const iTaxRootCA = iTax * ITAX_DISTRIBUTION.rootCA; // 40% to ROOT CA\r\n  const iTaxGarden = iTax * ITAX_DISTRIBUTION.indexer; // 30% to garden (legacy constant name)\r\n  const iTaxTrader = iTax * ITAX_DISTRIBUTION.trader; // 30% back to trader as rebate\r\n  \r\n  // Update ROOT CA liquidity (add iTax)\r\n  addRootCALiquidity(iTaxRootCA);\r\n  \r\n  // Update pool stats\r\n  pool.totalVolume += tradeValue;\r\n  pool.totalTrades += 1;\r\n  \r\n  // Update liquidity accountant service (async, don't block)\r\n  import(\"./liquidityAccountant\").then(({ updateLiquidityAfterTrade }) => {\r\n    updateLiquidityAfterTrade(\r\n      pool.poolId,\r\n      pool.baseReserve,\r\n      pool.tokenReserve,\r\n      tradeValue\r\n    );\r\n  }).catch((err: any) => {\r\n    console.warn(`\u26A0\uFE0F  [DEX] Failed to update liquidity accountant: ${err.message}`);\r\n  });\r\n  \r\n  // Create trade record\r\n  const trade: DEXTrade = {\r\n    tradeId: crypto.randomUUID(),\r\n    poolId: pool.poolId,\r\n    tokenSymbol: pool.tokenSymbol,\r\n    baseToken: pool.baseToken,\r\n    action,\r\n    tokenAmount,\r\n    baseAmount,\r\n    price: newPrice,\r\n    priceImpact: PRICE_IMPACT_PER_TRADE,\r\n    iTax,\r\n    timestamp: Date.now(),\r\n    trader: userEmail,\r\n  };\r\n  \r\n  console.log(`\uD83D\uDCB0 [DEX] Trade executed: ${action} ${tokenAmount} ${pool.tokenSymbol} for ${baseAmount.toFixed(6)} ${pool.baseToken}`);\r\n  console.log(`   Price: ${newPrice.toFixed(6)} ${pool.baseToken}/${pool.tokenSymbol}`);\r\n  console.log(`   iTax: ${iTax.toFixed(6)} ${pool.baseToken}`);\r\n  console.log(`   Distribution: ROOT CA ${iTaxRootCA.toFixed(6)}, Garden ${iTaxGarden.toFixed(6)}, Trader ${iTaxTrader.toFixed(6)}`);\r\n  \r\n  // Broadcast DEX trade event\r\n  broadcastEvent({\r\n    type: \"dex_trade_executed\",\r\n    component: \"dex\",\r\n    message: `DEX Trade: ${action} ${tokenAmount} ${pool.tokenSymbol}`,\r\n    timestamp: Date.now(),\r\n    data: {\r\n      trade,\r\n      iTaxDistribution: {\r\n        rootCA: iTaxRootCA,\r\n        garden: iTaxGarden,\r\n        trader: iTaxTrader,\r\n      },\r\n      poolState: {\r\n        price: pool.price,\r\n        liquidity: pool.poolLiquidity,\r\n        totalVolume: pool.totalVolume,\r\n        totalTrades: pool.totalTrades,\r\n      },\r\n      rootCALiquidity: rootCALiquidity,\r\n    }\r\n  });\r\n  \r\n  return trade;\r\n}\r\n\r\n/**\r\n * Calculate iGas cost for LLM operations\r\n */\r\nexport function calculateIGas(llmCalls: number, providersQueried: number, complexity: number = 1): number {\r\n  const llmCost = LLM_BASE_COST * llmCalls * complexity;\r\n  const routingCost = ROUTING_COST_PER_PROVIDER * providersQueried;\r\n  const reasoningCost = llmCost * REASONING_COST_MULTIPLIER;\r\n  return llmCost + routingCost + reasoningCost;\r\n}\r\n\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,aAAwB;AAExB,mBAAwG;AACxG,uBAA0I;AAG1I,IAAI,iBAAuC,MAAM;AAAC;AAElD,SAAS,gBAAgB,QAAwB;AAC/C,UAAQ,UAAU,IAAI,KAAK,EAAE,YAAY;AAC3C;AAEA,SAAS,2BAA2B,QAA+B;AAMjE,QAAM,aAAa,gBAAgB,MAAM;AACzC,MAAI,CAAC,WAAW,WAAW,cAAc;AAAG,WAAO;AACnD,QAAM,SAAS,WAAW,MAAM,eAAe,MAAM;AACrD,MAAI,CAAC;AAAQ,WAAO;AAGpB,QAAM,UAAU,OAAO,QAAQ,gBAAgB,EAAE,EAAE,YAAY;AAC/D,MAAI,CAAC;AAAS,WAAO;AAGrB,MAAI,QAAQ,WAAW,OAAO,GAAG;AAC/B,WAAO;AAAA,EACT;AAIA,SAAO;AACT;AAEA,SAAS,oBAAoB,QAAkC;AAC7D,QAAM,cAAc,2BAA2B,MAAM;AACrD,MAAI,CAAC;AAAa,WAAO;AAEzB,QAAM,WAAW,2BAAc,CAAC,GAAG,MAAM;AACzC,QAAM,cAAc,YAAY,QAAQ,UAAU,EAAE,KAAK;AACzD,QAAM,YAAY,SAAS,WAAW;AAEtC,QAAM,OAAkB;AAAA,IACtB,QAAQ,gBAAgB,MAAM;AAAA,IAC9B;AAAA,IACA;AAAA,IACA,WAAW;AAAA,IACX,eAAe;AAAA,IACf,cAAc;AAAA,IACd,aAAa;AAAA,IACb,OAAO;AAAA,IACP,MAAM;AAAA,IACN;AAAA,IACA,WAAW,KAAK,IAAI;AAAA,IACpB,aAAa;AAAA,IACb,aAAa;AAAA,EACf;AAEA,SAAO;AACT;AAKO,SAAS,cAAc,aAAyC;AACrE,mBAAiB;AACnB;AAKO,SAAS,qBAA2B;AAGzC,WAAS,IAAI,GAAG,IAAI,2BAAc,QAAQ,KAAK;AAC7C,UAAM,cAAc,2BAAc,CAAC;AACnC,QAAI,CAAC;AAAa;AAIlB,UAAM,cAAc;AACpB,UAAM,YAAY,SAAS,IAAI,CAAC;AAChC,UAAM,SAAS,qBAAqB,IAAI,CAAC;AAEzC,UAAM,OAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,eAAe,MAAO,IAAI;AAAA;AAAA,MAC1B,cAAc,MAAU,IAAI;AAAA;AAAA,MAC5B,aAAa,MAAO,IAAI;AAAA;AAAA,MACxB,OAAO;AAAA;AAAA,MACP,MAAM;AAAA,MACN,UAAU,YAAY;AAAA;AAAA,MACtB,WAAW,KAAK,IAAI;AAAA,MACpB,aAAa;AAAA,MACb,aAAa;AAAA,IACf;AACA,2BAAU,IAAI,QAAQ,IAAI;AAAA,EAC5B;AAEA,UAAQ,IAAI,yBAAkB,uBAAU,IAAI,YAAY;AACxD,UAAQ,IAAI,qCAA8B,4BAAe,MAAM;AAC/D,UAAQ,IAAI,4BAAqB,2BAAc,IAAI,QAAM,GAAG,IAAI,EAAE,KAAK,IAAI,CAAC,EAAE;AAG9E,aAAW,CAAC,QAAQ,IAAI,KAAK,uBAAU,QAAQ,GAAG;AAChD,YAAQ,IAAI,MAAM,KAAK,WAAW,gBAAW,KAAK,QAAQ,KAAK,KAAK,aAAa,iBAAiB;AAIlG,WAAO,uBAAuB,EAAE,KAAK,CAAC,EAAE,oBAAoB,yBAAyB,MAAM;AACzF,YAAM,WAAW,mBAAmB,MAAM;AAC1C,UAAI,CAAC,UAAU;AAEb;AAAA,UACE;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK,eAAe,KAAK;AAAA,UACzB,KAAK,eAAe,KAAK;AAAA,UACzB,KAAK;AAAA,UACL,KAAK;AAAA,QACP;AACA,gBAAQ,IAAI,+DAAwD,KAAK,WAAW,IAAI,KAAK,SAAS,EAAE;AAAA,MAC1G;AAAA,IACF,CAAC,EAAE,MAAM,CAAC,QAAa;AACrB,cAAQ,KAAK,6EAAmE,IAAI,OAAO,EAAE;AAAA,IAC/F,CAAC;AAAA,EACH;AACF;AAKO,SAAS,gBACd,QACA,QACA,aACA,WACU;AACV,QAAM,kBAAkB;AACxB,QAAM,mBAAmB,gBAAgB,MAAM;AAG/C,MAAI,OAAO,uBAAU,IAAI,eAAe,KAAK,uBAAU,IAAI,gBAAgB;AAG3E,MAAI,CAAC,MAAM;AACT,QAAI,uBAAU,SAAS,GAAG;AACxB,cAAQ,KAAK,yFAA+E;AAAA,IAC9F,OAAO;AACL,cAAQ,KAAK,6BAAmB,eAAe,oEAAoE;AAAA,IACrH;AACA,QAAI;AACF,yBAAmB;AAAA,IACrB,SAAS,KAAU;AACjB,cAAQ,KAAK,iEAAuD,KAAK,WAAW,GAAG,EAAE;AAAA,IAC3F;AACA,WAAO,uBAAU,IAAI,eAAe,KAAK,uBAAU,IAAI,gBAAgB;AAAA,EACzE;AAGA,MAAI,CAAC,QAAQ,uBAAU,OAAO,GAAG;AAC/B,UAAM,QAAQ,MAAM,KAAK,uBAAU,OAAO,CAAC,EAAE,KAAK,OAAK,gBAAgB,EAAE,MAAM,MAAM,gBAAgB;AACrG,QAAI;AAAO,aAAO;AAAA,EACpB;AAGA,MAAI,CAAC,MAAM;AACT,UAAM,YAAY,oBAAoB,eAAe;AACrD,QAAI,WAAW;AACb,6BAAU,IAAI,UAAU,QAAQ,SAAS;AACzC,aAAO;AACP,cAAQ;AAAA,QACN,6BAAmB,eAAe,0CAA0C,UAAU,MAAM,eAAe,UAAU,WAAW;AAAA,MAClI;AAAA,IACF;AAAA,EACF;AAEA,MAAI,CAAC,MAAM;AACT,UAAM,YAAY,MAAM,KAAK,uBAAU,KAAK,CAAC,EAAE,MAAM,GAAG,EAAE,EAAE,KAAK,IAAI;AACrE,UAAM,IAAI;AAAA,MACR,QAAQ,eAAe,2BAA2B,gBAAgB,qBAChD,uBAAU,IAAI,QAC/B,uBAAU,OAAO,iCAAiC,SAAS,KAAK;AAAA,IACnE;AAAA,EACF;AAMA,MAAI;AACJ,MAAI;AAEJ,MAAI,WAAW,OAAO;AAKpB,iBAAc,KAAK,cAAc,eAAgB,KAAK,eAAe;AAGrE,UAAM,cAAc;AACpB,iBAAa,cAAc,IAAI;AAG/B,SAAK,eAAe;AACpB,SAAK,gBAAgB;AAGrB,eAAW,KAAK,cAAc,KAAK;AACnC,SAAK,QAAQ;AAGb,SAAK,iBAAkB,IAAI;AAAA,EAC7B,OAAO;AAGL,iBAAc,KAAK,cAAc,eAAgB,KAAK,eAAe;AAGrE,UAAM,cAAc;AACpB,iBAAa,cAAc,IAAI;AAG/B,SAAK,eAAe;AACpB,SAAK,gBAAgB;AAGrB,eAAW,KAAK,cAAc,KAAK;AACnC,SAAK,QAAQ;AAGb,SAAK,iBAAkB,IAAI;AAAA,EAC7B;AAGA,QAAM,aAAa;AACnB,MAAI,OAAO,aAAa;AAIxB,QAAM,iBAAiB,YAAY,KAAK,YAAY,YAAY,CAAC;AACjE,QAAM,eAAe,sCAAyB,KAAK,OAAK,EAAE,OAAO,cAAc;AAC/E,MAAK,cAAsB,iBAAiB,SAAS;AACnD,UAAM,sBAAuB,aAAqB,kBAAkB;AACpE,WAAO,OAAO;AACd,YAAQ,IAAI,uDAAgD,mBAAmB,cAAc,MAAM,EAAE;AAAA,EACvG;AAGA,QAAM,aAAa,OAAO,mCAAkB;AAC5C,QAAM,aAAa,OAAO,mCAAkB;AAC5C,QAAM,aAAa,OAAO,mCAAkB;AAG5C,uCAAmB,UAAU;AAG7B,OAAK,eAAe;AACpB,OAAK,eAAe;AAGpB,SAAO,uBAAuB,EAAE,KAAK,CAAC,EAAE,0BAA0B,MAAM;AACtE;AAAA,MACE,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,IACF;AAAA,EACF,CAAC,EAAE,MAAM,CAAC,QAAa;AACrB,YAAQ,KAAK,8DAAoD,IAAI,OAAO,EAAE;AAAA,EAChF,CAAC;AAGD,QAAM,QAAkB;AAAA,IACtB,SAAS,OAAO,WAAW;AAAA,IAC3B,QAAQ,KAAK;AAAA,IACb,aAAa,KAAK;AAAA,IAClB,WAAW,KAAK;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,aAAa;AAAA,IACb;AAAA,IACA,WAAW,KAAK,IAAI;AAAA,IACpB,QAAQ;AAAA,EACV;AAEA,UAAQ,IAAI,mCAA4B,MAAM,IAAI,WAAW,IAAI,KAAK,WAAW,QAAQ,WAAW,QAAQ,CAAC,CAAC,IAAI,KAAK,SAAS,EAAE;AAClI,UAAQ,IAAI,aAAa,SAAS,QAAQ,CAAC,CAAC,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW,EAAE;AACpF,UAAQ,IAAI,YAAY,KAAK,QAAQ,CAAC,CAAC,IAAI,KAAK,SAAS,EAAE;AAC3D,UAAQ,IAAI,4BAA4B,WAAW,QAAQ,CAAC,CAAC,YAAY,WAAW,QAAQ,CAAC,CAAC,YAAY,WAAW,QAAQ,CAAC,CAAC,EAAE;AAGjI,iBAAe;AAAA,IACb,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS,cAAc,MAAM,IAAI,WAAW,IAAI,KAAK,WAAW;AAAA,IAChE,WAAW,KAAK,IAAI;AAAA,IACpB,MAAM;AAAA,MACJ;AAAA,MACA,kBAAkB;AAAA,QAChB,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,QAAQ;AAAA,MACV;AAAA,MACA,WAAW;AAAA,QACT,OAAO,KAAK;AAAA,QACZ,WAAW,KAAK;AAAA,QAChB,aAAa,KAAK;AAAA,QAClB,aAAa,KAAK;AAAA,MACpB;AAAA,MACA,iBAAiB;AAAA,IACnB;AAAA,EACF,CAAC;AAED,SAAO;AACT;AAKO,SAAS,cAAc,UAAkB,kBAA0B,aAAqB,GAAW;AACxG,QAAM,UAAU,iCAAgB,WAAW;AAC3C,QAAM,cAAc,6CAA4B;AAChD,QAAM,gBAAgB,UAAU;AAChC,SAAO,UAAU,cAAc;AACjC;",
  "names": []
}
