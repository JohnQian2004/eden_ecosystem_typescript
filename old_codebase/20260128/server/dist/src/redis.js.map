{
  "version": 3,
  "sources": ["../../src/redis.ts"],
  "sourcesContent": ["/**\r\n * In-Memory Redis Server Module\r\n * Provides an in-memory Redis-compatible server with persistence\r\n */\r\n\r\nimport * as fs from \"fs\";\r\nimport * as path from \"path\";\r\nimport * as crypto from \"crypto\";\r\nimport { EventEmitter } from \"events\";\r\nimport { DEPLOYED_AS_ROOT } from \"./config\";\r\nimport { GARDENS, TOKEN_GARDENS, ROOT_CA_SERVICE_REGISTRY } from \"./state\";\r\nimport type { ServiceProviderWithCert } from \"./types\";\r\n\r\n/**\r\n * In-memory Redis server implementation with persistence\r\n * Supports key-value operations, streams, and consumer groups\r\n */\r\nexport class InMemoryRedisServer extends EventEmitter {\r\n  private data: Map<string, any> = new Map();\r\n  private streams: Map<string, Array<{ id: string; fields: Record<string, string> }>> = new Map();\r\n  private streamCounters: Map<string, number> = new Map();\r\n  private consumerGroups: Map<string, Map<string, string>> = new Map(); // stream -> group -> lastId\r\n  private pendingMessages: Map<string, Map<string, Array<{ id: string; fields: Record<string, string> }>>> = new Map(); // stream -> group -> messages\r\n  private isConnected = false;\r\n  private persistenceFile: string; // Main wallet persistence file (backward compatibility)\r\n  private ledgerEntriesFile: string; // Separate file for ledger entries\r\n  private gardensFile: string; // Separate file for gardens\r\n  private serviceRegistryFile: string; // Separate file for service registry\r\n  private saveTimeout: NodeJS.Timeout | null = null;\r\n  private readonly SAVE_DELAY_MS = 1000; // Debounce saves by 1 second\r\n  private serviceRegistrySaveTimer: NodeJS.Timeout | null = null;\r\n  private serviceRegistrySavePending: boolean = false;\r\n\r\n  constructor() {\r\n    super();\r\n    // Persistence files in the same directory as the script\r\n    this.persistenceFile = path.join(__dirname, '..', 'eden-wallet-persistence.json');\r\n    this.ledgerEntriesFile = path.join(__dirname, '..', 'eden-ledgerEntries-persistence.json');\r\n    this.gardensFile = path.join(__dirname, '..', 'eden-gardens-persistence.json');\r\n    this.serviceRegistryFile = path.join(__dirname, '..', 'eden-serviceRegistry-persistence.json');\r\n    this.loadPersistence();\r\n  }\r\n\r\n  // Load wallet data, ledger entries, and indexers from persistence files\r\n  // REFACTOR: Now uses separate files for each data type, with backward compatibility\r\n  // CRITICAL: This method should ONLY be called during server startup (constructor)\r\n  // NEVER call this during runtime - it will overwrite in-memory state!\r\n  private loadPersistence(): { walletBalances: Record<string, string>, ledgerEntries: any[], indexers: any[] } {\r\n    // CRITICAL: Prevent reloading during runtime - only allow during server startup\r\n    if (this.persistenceLoaded) {\r\n      console.error(`\u274C [Redis Persistence] CRITICAL ERROR: loadPersistence() called AFTER server startup! This should NEVER happen!`);\r\n      console.error(`\u274C [Redis Persistence] Stack trace:`, new Error().stack);\r\n      throw new Error('loadPersistence() can only be called during server startup (constructor), not during runtime!');\r\n    }\r\n    const result: { walletBalances: Record<string, string>, ledgerEntries: any[], indexers: any[] } = { walletBalances: {}, ledgerEntries: [], indexers: [] };\r\n    \r\n    // Check if we should migrate from old combined file\r\n    const hasOldFile = fs.existsSync(this.persistenceFile);\r\n    const hasNewFiles = fs.existsSync(this.ledgerEntriesFile) || fs.existsSync(this.gardensFile) || fs.existsSync(this.serviceRegistryFile);\r\n    \r\n    // If old file exists but new files don't, migrate\r\n    if (hasOldFile && !hasNewFiles) {\r\n      console.log(`\uD83D\uDD04 [Persistence Migration] Detected old combined file, migrating to separate files...`);\r\n      this.migrateToSeparateFiles();\r\n    }\r\n    \r\n    try {\r\n      // Load wallet balances (always from main file for now, for backward compatibility)\r\n      if (fs.existsSync(this.persistenceFile)) {\r\n        const fileContent = fs.readFileSync(this.persistenceFile, 'utf-8');\r\n        const persisted = JSON.parse(fileContent);\r\n        \r\n        // Restore wallet balances and audit logs\r\n        if (persisted.walletBalances && Object.keys(persisted.walletBalances).length > 0) {\r\n          for (const [key, value] of Object.entries(persisted.walletBalances)) {\r\n            this.data.set(key, value);\r\n            // Log balance keys for debugging\r\n            if (key.startsWith('wallet:balance:')) {\r\n              console.log(`\uD83D\uDCC2 [Redis Persistence] Loaded wallet balance: ${key} = ${value}`);\r\n            }\r\n          }\r\n          result.walletBalances = persisted.walletBalances;\r\n          console.log(`\uD83D\uDCC2 [Redis Persistence] Loaded ${Object.keys(persisted.walletBalances).length} wallet balances from ${this.persistenceFile}`);\r\n        } else {\r\n          console.log(`\uD83D\uDCC2 [Redis Persistence] No wallet balances found in persistence file (starting with empty wallets)`);\r\n        }\r\n      }\r\n      \r\n      // Load ledger entries from separate file\r\n      if (fs.existsSync(this.ledgerEntriesFile)) {\r\n        try {\r\n          const fileContent = fs.readFileSync(this.ledgerEntriesFile, 'utf-8');\r\n          const persisted = JSON.parse(fileContent);\r\n          if (persisted.ledgerEntries && Array.isArray(persisted.ledgerEntries) && persisted.ledgerEntries.length > 0) {\r\n            // CRITICAL: Normalize numeric fields when loading from persistence\r\n            // JSON.parse may have stored numbers as strings, so we need to convert them back\r\n            result.ledgerEntries = persisted.ledgerEntries.map((entry: any) => ({\r\n              ...entry,\r\n              iGasCost: typeof entry.iGasCost === 'string' ? parseFloat(entry.iGasCost) : (entry.iGasCost || 0),\r\n              amount: typeof entry.amount === 'string' ? parseFloat(entry.amount) : (entry.amount || 0),\r\n              timestamp: typeof entry.timestamp === 'string' ? parseInt(entry.timestamp) : (entry.timestamp || Date.now()),\r\n              fees: entry.fees ? Object.fromEntries(\r\n                Object.entries(entry.fees).map(([key, value]: [string, any]) => [\r\n                  key,\r\n                  typeof value === 'string' ? parseFloat(value) : (value || 0)\r\n                ])\r\n              ) : {}\r\n            }));\r\n            console.log(`\uD83D\uDCC2 [Redis Persistence] Loaded ${persisted.ledgerEntries.length} ledger entries from ${this.ledgerEntriesFile} (normalized numeric fields)`);\r\n          }\r\n        } catch (err: any) {\r\n          console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load ledger entries from separate file: ${err.message}`);\r\n        }\r\n      } else if (hasOldFile) {\r\n        // Fallback to old file for backward compatibility\r\n        const fileContent = fs.readFileSync(this.persistenceFile, 'utf-8');\r\n        const persisted = JSON.parse(fileContent);\r\n        if (persisted.ledgerEntries && Array.isArray(persisted.ledgerEntries) && persisted.ledgerEntries.length > 0) {\r\n          // CRITICAL: Normalize numeric fields when loading from persistence\r\n          result.ledgerEntries = persisted.ledgerEntries.map((entry: any) => ({\r\n            ...entry,\r\n            iGasCost: typeof entry.iGasCost === 'string' ? parseFloat(entry.iGasCost) : (entry.iGasCost || 0),\r\n            amount: typeof entry.amount === 'string' ? parseFloat(entry.amount) : (entry.amount || 0),\r\n            timestamp: typeof entry.timestamp === 'string' ? parseInt(entry.timestamp) : (entry.timestamp || Date.now()),\r\n            fees: entry.fees ? Object.fromEntries(\r\n              Object.entries(entry.fees).map(([key, value]: [string, any]) => [\r\n                key,\r\n                typeof value === 'string' ? parseFloat(value) : (value || 0)\r\n              ])\r\n            ) : {}\r\n          }));\r\n          console.log(`\uD83D\uDCC2 [Redis Persistence] Loaded ${persisted.ledgerEntries.length} ledger entries from old combined file (will migrate on next save, normalized numeric fields)`);\r\n        }\r\n      }\r\n      \r\n      // Load gardens from separate file\r\n      if (fs.existsSync(this.gardensFile)) {\r\n        try {\r\n          const fileContent = fs.readFileSync(this.gardensFile, 'utf-8');\r\n          const persisted = JSON.parse(fileContent);\r\n          const gardensToLoad = persisted.gardens || persisted.indexers || [];\r\n          if (gardensToLoad && Array.isArray(gardensToLoad) && gardensToLoad.length > 0) {\r\n            // CRITICAL: Deduplicate gardens when loading to prevent duplicates in memory\r\n            const deduplicatedGardens = new Map<string, any>();\r\n            for (const garden of gardensToLoad) {\r\n              const existing = deduplicatedGardens.get(garden.id);\r\n              if (!existing) {\r\n                deduplicatedGardens.set(garden.id, garden);\r\n              } else {\r\n                // Prefer the one with certificate\r\n                const hasCert = !!(garden as any).certificate;\r\n                const existingHasCert = !!(existing as any).certificate;\r\n                if (hasCert && !existingHasCert) {\r\n                  deduplicatedGardens.set(garden.id, garden);\r\n                  console.warn(`\u26A0\uFE0F  [Indexer Persistence] Found duplicate garden ${garden.id} when loading - keeping version with certificate`);\r\n                } else {\r\n                  console.warn(`\u26A0\uFE0F  [Indexer Persistence] Found duplicate garden ${garden.id} when loading - keeping existing version`);\r\n                }\r\n              }\r\n            }\r\n            const cleanGardens = Array.from(deduplicatedGardens.values());\r\n            result.indexers = cleanGardens;\r\n            if (gardensToLoad.length !== cleanGardens.length) {\r\n              console.warn(`\u26A0\uFE0F  [Indexer Persistence] Removed ${gardensToLoad.length - cleanGardens.length} duplicate(s) when loading gardens from persistence file`);\r\n            }\r\n            console.log(`\uD83D\uDCC2 [Redis Persistence] Loaded ${cleanGardens.length} persisted gardens from ${this.gardensFile}`);\r\n          }\r\n        } catch (err: any) {\r\n          console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load gardens from separate file: ${err.message}`);\r\n        }\r\n      } else if (hasOldFile) {\r\n        // Fallback to old file for backward compatibility\r\n        const fileContent = fs.readFileSync(this.persistenceFile, 'utf-8');\r\n        const persisted = JSON.parse(fileContent);\r\n        const gardensToLoad = persisted.gardens || persisted.indexers;\r\n        if (gardensToLoad && Array.isArray(gardensToLoad) && gardensToLoad.length > 0) {\r\n          // CRITICAL: Deduplicate gardens when loading to prevent duplicates in memory\r\n          const deduplicatedGardens = new Map<string, any>();\r\n          for (const garden of gardensToLoad) {\r\n            const existing = deduplicatedGardens.get(garden.id);\r\n            if (!existing) {\r\n              deduplicatedGardens.set(garden.id, garden);\r\n      } else {\r\n              // Prefer the one with certificate\r\n              const hasCert = !!(garden as any).certificate;\r\n              const existingHasCert = !!(existing as any).certificate;\r\n              if (hasCert && !existingHasCert) {\r\n                deduplicatedGardens.set(garden.id, garden);\r\n                console.warn(`\u26A0\uFE0F  [Indexer Persistence] Found duplicate garden ${garden.id} when loading - keeping version with certificate`);\r\n              } else {\r\n                console.warn(`\u26A0\uFE0F  [Indexer Persistence] Found duplicate garden ${garden.id} when loading - keeping existing version`);\r\n              }\r\n            }\r\n          }\r\n          const cleanGardens = Array.from(deduplicatedGardens.values());\r\n          result.indexers = cleanGardens;\r\n          if (gardensToLoad.length !== cleanGardens.length) {\r\n            console.warn(`\u26A0\uFE0F  [Indexer Persistence] Removed ${gardensToLoad.length - cleanGardens.length} duplicate(s) when loading gardens from persistence file`);\r\n          }\r\n          console.log(`\uD83D\uDCC2 [Redis Persistence] Loaded ${cleanGardens.length} persisted gardens from old combined file (will migrate on next save)`);\r\n        }\r\n      }\r\n      \r\n      // Load service registry from separate file and merge with ROOT_CA_SERVICE_REGISTRY\r\n      if (fs.existsSync(this.serviceRegistryFile)) {\r\n        try {\r\n          const fileContent = fs.readFileSync(this.serviceRegistryFile, 'utf-8');\r\n          const persisted = JSON.parse(fileContent);\r\n          if (persisted.serviceRegistry && Array.isArray(persisted.serviceRegistry) && persisted.serviceRegistry.length > 0) {\r\n            console.log(`\uD83D\uDCC2 [Redis Persistence] Loading ${persisted.serviceRegistry.length} service providers from ${this.serviceRegistryFile}`);\r\n            \r\n            // CRITICAL: Get loaded gardens from result.indexers (they haven't been added to GARDENS/TOKEN_GARDENS yet)\r\n            // Separate regular and token gardens from the loaded data\r\n            const loadedRegularGardens = result.indexers.filter((g: any) => \r\n              !(g.tokenServiceType === 'dex' || (g.serviceType === 'dex' && g.id && g.id.startsWith('T')))\r\n            );\r\n            const loadedTokenGardens = result.indexers.filter((g: any) => \r\n              g.tokenServiceType === 'dex' || (g.serviceType === 'dex' && g.id && g.id.startsWith('T'))\r\n            );\r\n            \r\n            // Merge persisted service registry with in-memory ROOT_CA_SERVICE_REGISTRY\r\n            // Update existing providers' indexerId if they exist in both\r\n            let updatedCount = 0;\r\n            for (const persistedProvider of persisted.serviceRegistry) {\r\n              const persistedGardenId = persistedProvider.gardenId || persistedProvider.indexerId;\r\n              \r\n              // CRITICAL: Only load providers whose gardens actually exist (or are \"HG\" for infrastructure)\r\n              // Check if the garden exists in loaded gardens (from persistence file) or in-memory arrays\r\n              const gardenExists = persistedGardenId === 'HG' || \r\n                                  loadedRegularGardens.some((g: any) => g.id === persistedGardenId) ||\r\n                                  loadedTokenGardens.some((g: any) => g.id === persistedGardenId) ||\r\n                                  GARDENS.some(g => g.id === persistedGardenId) || \r\n                                  TOKEN_GARDENS.some(tg => tg.id === persistedGardenId);\r\n              \r\n              if (!gardenExists && persistedGardenId) {\r\n                console.log(`\u26A0\uFE0F  [Service Registry] Skipping provider ${persistedProvider.id} (${persistedProvider.name}): gardenId \"${persistedGardenId}\" does not exist in loaded gardens or GARDENS/TOKEN_GARDENS`);\r\n                console.log(`   \uD83D\uDD0D Available gardens: ${[...GARDENS.map(g => g.id), ...TOKEN_GARDENS.map(tg => tg.id), 'HG'].join(', ')}`);\r\n                // CRITICAL: Only remove providers during INITIAL load, not if they're already in memory\r\n                // If a provider is already in ROOT_CA_SERVICE_REGISTRY, it means it was added dynamically\r\n                // and we should NOT remove it just because the garden check failed (timing issue)\r\n                const existingProvider = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === persistedProvider.id);\r\n                if (existingProvider) {\r\n                  // Provider already exists in memory - don't remove it, just skip loading from file\r\n                  console.log(`   \u26A0\uFE0F  [Service Registry] Provider ${persistedProvider.id} already in memory, keeping it (garden may be loading)`);\r\n                  continue; // Skip loading from file, but keep the in-memory version\r\n                }\r\n                // Only skip if provider doesn't exist in memory (initial load scenario)\r\n                continue; // Skip this provider\r\n              }\r\n              \r\n              const existingProvider = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === persistedProvider.id);\r\n              if (existingProvider) {\r\n                // Update gardenId from persisted file (this is the source of truth for provider assignments)\r\n                // Support both indexerId and gardenId for backward compatibility\r\n                \r\n                // CRITICAL FIX: Correct incorrect \"HG\" assignments for movie providers\r\n                // Movie providers should never be assigned to \"HG\" - they belong to regular gardens\r\n                // If file has \"HG\" but in-memory default is \"garden-1\", use the correct default instead\r\n                let resolvedGardenId = persistedGardenId;\r\n                if (resolvedGardenId === \"HG\" && existingProvider.serviceType === \"movie\") {\r\n                  const correctGardenId = existingProvider.gardenId; // Use in-memory default (should be \"garden-1\")\r\n                  if (correctGardenId && correctGardenId !== \"HG\") {\r\n                    console.log(`\uD83D\uDD27 [Service Registry] CORRECTING ${existingProvider.name} (${existingProvider.id}): file has incorrect gardenId=\"HG\" for movie provider, using correct default=\"${correctGardenId}\"`);\r\n                    resolvedGardenId = correctGardenId;\r\n                  }\r\n                }\r\n                \r\n                console.log(`\uD83D\uDD0D [Service Registry Load] Processing ${persistedProvider.id}: file has gardenId=\"${persistedProvider.gardenId}\", resolved=\"${resolvedGardenId}\", in-memory has gardenId=\"${existingProvider.gardenId}\"`);\r\n                if (resolvedGardenId) {\r\n                  // ALWAYS update from file (file is source of truth), even if values appear the same\r\n                  // This ensures provider assignments are preserved after server restart\r\n                  // CRITICAL: The in-memory default might be \"HG\" but the file has \"garden-1\" - file wins!\r\n                  const oldValue = existingProvider.gardenId;\r\n                  existingProvider.gardenId = resolvedGardenId;\r\n                  if (oldValue !== resolvedGardenId) {\r\n                    console.log(`\uD83D\uDCC2 [Service Registry] \u2705 UPDATED ${existingProvider.name} (${existingProvider.id}): gardenId from \"${oldValue}\" to \"${resolvedGardenId}\" (from file)`);\r\n                    updatedCount++;\r\n                  } else {\r\n                    console.log(`\uD83D\uDCC2 [Service Registry] \u2713 ${existingProvider.name} (${existingProvider.id}) already has correct gardenId: \"${resolvedGardenId}\"`);\r\n                  }\r\n                } else {\r\n                  console.log(`\u26A0\uFE0F  [Service Registry] ${persistedProvider.id} has no gardenId in file, skipping update`);\r\n                }\r\n              } else {\r\n                // Provider doesn't exist in defaults, add it (for dynamically created providers)\r\n                console.log(`\uD83D\uDCC2 [Service Registry] Adding persisted provider: ${persistedProvider.name} (${persistedProvider.id}) with gardenId=${persistedGardenId}`);\r\n                // Check if provider already exists (by ID or UUID) to avoid duplicates\r\n                const existingById = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === persistedProvider.id);\r\n                const existingByUuid = persistedProvider.uuid ? ROOT_CA_SERVICE_REGISTRY.find(p => p.uuid === persistedProvider.uuid) : null;\r\n                \r\n                if (existingById || existingByUuid) {\r\n                  console.log(`\u26A0\uFE0F  [Service Registry] Provider ${persistedProvider.id} already exists in ROOT_CA_SERVICE_REGISTRY, skipping duplicate`);\r\n                } else {\r\n                  // Ensure all required fields are present before adding\r\n                  const providerToAdd: ServiceProviderWithCert = {\r\n                    id: persistedProvider.id,\r\n                    uuid: persistedProvider.uuid || crypto.randomUUID(),\r\n                    name: persistedProvider.name,\r\n                    serviceType: persistedProvider.serviceType,\r\n                    location: persistedProvider.location || 'Unknown',\r\n                    bond: persistedProvider.bond || 0,\r\n                    reputation: persistedProvider.reputation || 0,\r\n                    gardenId: persistedGardenId || 'HG',\r\n                    apiEndpoint: persistedProvider.apiEndpoint,\r\n                    status: (persistedProvider.status as 'active' | 'revoked' | 'suspended') || 'active',\r\n                    // Optional fields\r\n                    insuranceFee: persistedProvider.insuranceFee,\r\n                    iGasMultiplier: persistedProvider.iGasMultiplier,\r\n                    iTaxMultiplier: persistedProvider.iTaxMultiplier,\r\n                    maxInfluence: persistedProvider.maxInfluence,\r\n                    contextsAllowed: persistedProvider.contextsAllowed,\r\n                    contextsForbidden: persistedProvider.contextsForbidden,\r\n                    adCapabilities: persistedProvider.adCapabilities,\r\n                    certificate: persistedProvider.certificate\r\n                  };\r\n                  ROOT_CA_SERVICE_REGISTRY.push(providerToAdd);\r\n                  console.log(`\u2705 [Service Registry] Successfully added provider: ${providerToAdd.name} (${providerToAdd.id}) with serviceType=${providerToAdd.serviceType}, gardenId=${providerToAdd.gardenId}`);\r\n                }\r\n              }\r\n            }\r\n            if (updatedCount > 0) {\r\n              console.log(`\uD83D\uDCC2 [Service Registry] Updated ${updatedCount} provider gardenId assignment(s) from persistence file`);\r\n              // If we corrected any \"HG\" assignments for movie providers, save the corrected values back to file\r\n              const correctedCount = ROOT_CA_SERVICE_REGISTRY.filter(p => {\r\n                const persistedProvider = persisted.serviceRegistry.find((pp: any) => pp.id === p.id);\r\n                return persistedProvider && \r\n                       persistedProvider.gardenId === \"HG\" && \r\n                       p.serviceType === \"movie\" && \r\n                       p.gardenId !== \"HG\";\r\n              }).length;\r\n              if (correctedCount > 0) {\r\n                console.log(`\uD83D\uDD27 [Service Registry] Corrected ${correctedCount} movie provider(s) from \"HG\" to correct gardenId - saving corrected values to file`);\r\n                // Save the corrected values immediately\r\n                this.saveServiceRegistry();\r\n              }\r\n            }\r\n            // Log final state of providers after loading\r\n            const movieProvidersAfterLoad = ROOT_CA_SERVICE_REGISTRY.filter(p => p.serviceType === 'movie');\r\n            if (movieProvidersAfterLoad.length > 0) {\r\n              console.log(`\uD83D\uDCC2 [Service Registry] After load - Movie providers: ${movieProvidersAfterLoad.map(p => `${p.name} (${p.id}) \u2192 gardenId: ${p.gardenId}`).join(', ')}`);\r\n            }\r\n            const dexProvidersAfterLoad = ROOT_CA_SERVICE_REGISTRY.filter(p => p.serviceType === 'dex');\r\n            if (dexProvidersAfterLoad.length > 0) {\r\n              console.log(`\uD83D\uDCC2 [Service Registry] After load - DEX providers: ${dexProvidersAfterLoad.map(p => `${p.name} (${p.id}) \u2192 gardenId: ${p.gardenId}`).join(', ')}`);\r\n            } else {\r\n              console.log(`\u26A0\uFE0F  [Service Registry] After load - No DEX providers found in ROOT_CA_SERVICE_REGISTRY (total providers: ${ROOT_CA_SERVICE_REGISTRY.length})`);\r\n            }\r\n            console.log(`\u2705 [Service Registry] Merged service registry: ${ROOT_CA_SERVICE_REGISTRY.length} total providers`);\r\n          }\r\n        } catch (err: any) {\r\n          console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load service registry from separate file: ${err.message}`);\r\n        }\r\n      } else if (hasOldFile) {\r\n        // Fallback to old file for backward compatibility\r\n        try {\r\n          const fileContent = fs.readFileSync(this.persistenceFile, 'utf-8');\r\n          const persisted = JSON.parse(fileContent);\r\n          if (persisted.serviceRegistry && Array.isArray(persisted.serviceRegistry) && persisted.serviceRegistry.length > 0) {\r\n            console.log(`\uD83D\uDCC2 [Redis Persistence] Loading ${persisted.serviceRegistry.length} service providers from old combined file (will migrate on next save)`);\r\n            \r\n            // Merge persisted service registry with in-memory ROOT_CA_SERVICE_REGISTRY\r\n            for (const persistedProvider of persisted.serviceRegistry) {\r\n              const persistedGardenId = persistedProvider.gardenId || persistedProvider.indexerId;\r\n              \r\n              // CRITICAL: Only load providers whose gardens actually exist (or are \"HG\" for infrastructure)\r\n              // Check if the garden exists in loaded gardens or in-memory arrays\r\n              const gardenExists = persistedGardenId === 'HG' || \r\n                                  GARDENS.some(g => g.id === persistedGardenId) || \r\n                                  TOKEN_GARDENS.some(tg => tg.id === persistedGardenId);\r\n              \r\n              if (!gardenExists && persistedGardenId) {\r\n                console.log(`\u26A0\uFE0F  [Service Registry] Skipping provider ${persistedProvider.id} (${persistedProvider.name}): gardenId \"${persistedGardenId}\" does not exist (from old file)`);\r\n                continue; // Skip this provider\r\n              }\r\n              \r\n              const existingProvider = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === persistedProvider.id);\r\n              if (existingProvider) {\r\n                // Update gardenId from persisted file\r\n                if (persistedGardenId) {\r\n                  // ALWAYS update from file (file is source of truth)\r\n                  const oldValue = existingProvider.gardenId;\r\n                  existingProvider.gardenId = persistedGardenId;\r\n                  if (oldValue !== persistedGardenId) {\r\n                    console.log(`\uD83D\uDCC2 [Service Registry] Updating ${existingProvider.name} (${existingProvider.id}): gardenId from \"${oldValue}\" to \"${persistedGardenId}\" (from old file)`);\r\n                  }\r\n                }\r\n              } else {\r\n                // Provider doesn't exist in defaults, add it (but only if garden exists)\r\n                console.log(`\uD83D\uDCC2 [Service Registry] Adding persisted provider: ${persistedProvider.name} (${persistedProvider.id}) with gardenId=${persistedGardenId}`);\r\n                ROOT_CA_SERVICE_REGISTRY.push(persistedProvider as ServiceProviderWithCert);\r\n              }\r\n            }\r\n            console.log(`\u2705 [Service Registry] Merged service registry from old file: ${ROOT_CA_SERVICE_REGISTRY.length} total providers`);\r\n          }\r\n        } catch (err: any) {\r\n          console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load service registry from old file: ${err.message}`);\r\n        }\r\n      }\r\n      \r\n      if (!hasOldFile && !hasNewFiles) {\r\n        console.log(`\uD83D\uDCC2 [Redis Persistence] No persistence files found, starting fresh`);\r\n      }\r\n    } catch (err: any) {\r\n      console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load persistence file: ${err.message}`);\r\n    }\r\n    return result;\r\n  }\r\n  \r\n  // Migrate from old combined file to separate files\r\n  private migrateToSeparateFiles(): void {\r\n    try {\r\n      if (!fs.existsSync(this.persistenceFile)) {\r\n        return; // Nothing to migrate\r\n      }\r\n      \r\n      console.log(`\uD83D\uDD04 [Persistence Migration] Reading old combined file: ${this.persistenceFile}`);\r\n      const fileContent = fs.readFileSync(this.persistenceFile, 'utf-8');\r\n      const persisted = JSON.parse(fileContent);\r\n      \r\n      // Migrate ledger entries\r\n      if (persisted.ledgerEntries && Array.isArray(persisted.ledgerEntries) && persisted.ledgerEntries.length > 0) {\r\n        const ledgerData = {\r\n          ledgerEntries: persisted.ledgerEntries,\r\n          lastSaved: persisted.lastSaved || new Date().toISOString()\r\n        };\r\n        fs.writeFileSync(this.ledgerEntriesFile, JSON.stringify(ledgerData, null, 2), 'utf-8');\r\n        console.log(`\u2705 [Persistence Migration] Migrated ${persisted.ledgerEntries.length} ledger entries to ${this.ledgerEntriesFile}`);\r\n      }\r\n      \r\n      // Migrate gardens\r\n      const gardensToMigrate = persisted.gardens || persisted.indexers;\r\n      if (gardensToMigrate && Array.isArray(gardensToMigrate) && gardensToMigrate.length > 0) {\r\n        const gardensData = {\r\n          gardens: gardensToMigrate,\r\n          lastSaved: persisted.lastSaved || new Date().toISOString()\r\n        };\r\n        fs.writeFileSync(this.gardensFile, JSON.stringify(gardensData, null, 2), 'utf-8');\r\n        console.log(`\u2705 [Persistence Migration] Migrated ${gardensToMigrate.length} gardens to ${this.gardensFile}`);\r\n      }\r\n      \r\n      // Migrate service registry\r\n      if (persisted.serviceRegistry && Array.isArray(persisted.serviceRegistry) && persisted.serviceRegistry.length > 0) {\r\n        const serviceRegistryData = {\r\n          serviceRegistry: persisted.serviceRegistry,\r\n          lastSaved: persisted.lastSaved || new Date().toISOString()\r\n        };\r\n        fs.writeFileSync(this.serviceRegistryFile, JSON.stringify(serviceRegistryData, null, 2), 'utf-8');\r\n        console.log(`\u2705 [Persistence Migration] Migrated ${persisted.serviceRegistry.length} service providers to ${this.serviceRegistryFile}`);\r\n      }\r\n      \r\n      // Keep wallet balances in the main file (for now, can be migrated later if needed)\r\n      console.log(`\u2705 [Persistence Migration] Migration complete. Wallet balances remain in ${this.persistenceFile}`);\r\n    } catch (err: any) {\r\n      console.error(`\u274C [Persistence Migration] Failed to migrate: ${err.message}`);\r\n    }\r\n  }\r\n\r\n  // Save wallet data, ledger entries, and indexers to persistence file (debounced)\r\n  // CRITICAL: In ROOT mode, indexers should NOT be saved here - they're saved via immediate save in /api/wizard/create-indexer\r\n  private savePersistence(ledgerEntries?: any[], indexers?: any[]): void {\r\n    // Clear existing timeout\r\n    if (this.saveTimeout) {\r\n      clearTimeout(this.saveTimeout);\r\n    }\r\n\r\n    // Debounce saves to avoid too many file writes\r\n    this.saveTimeout = setTimeout(() => {\r\n      try {\r\n        // CRITICAL: Load existing wallet balances FIRST to preserve them\r\n        // We must merge wallet balances, not overwrite them\r\n        let existingWalletBalances: Record<string, string> = {};\r\n        \r\n        if (fs.existsSync(this.persistenceFile)) {\r\n          try {\r\n            const fileContent = fs.readFileSync(this.persistenceFile, 'utf-8');\r\n            const existing = JSON.parse(fileContent);\r\n            if (existing.walletBalances && typeof existing.walletBalances === 'object') {\r\n              existingWalletBalances = existing.walletBalances;\r\n            }\r\n          } catch (err: any) {\r\n            console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load existing wallet balances: ${err.message}`);\r\n          }\r\n        }\r\n        \r\n        // Start with existing wallet balances from file (preserve them)\r\n        const walletBalances: Record<string, string> = { ...existingWalletBalances };\r\n        \r\n        // CRITICAL: Update wallet balances from in-memory (including 0 balances)\r\n        // 0 is a valid balance state after debits, so we must save it\r\n        for (const [key, value] of this.data.entries()) {\r\n          if (key.startsWith('wallet:balance:')) {\r\n            // Always update balance if it exists in memory (including 0)\r\n            const balanceValue = typeof value === 'string' ? value : JSON.stringify(value);\r\n            const balanceNum = parseFloat(balanceValue);\r\n            // Update if balance exists in memory AND is a valid number (including 0)\r\n            if (!isNaN(balanceNum) && balanceNum >= 0) {\r\n              walletBalances[key] = balanceValue;\r\n            }\r\n            // If balance is invalid (NaN or negative), preserve existing from file\r\n          } else if (key.startsWith('wallet:audit:')) {\r\n            // Always update audit logs (they're append-only)\r\n            walletBalances[key] = typeof value === 'string' ? value : JSON.stringify(value);\r\n          }\r\n        }\r\n\r\n        // Load existing ledger entries from separate file (or old file for backward compatibility)\r\n        let existingLedgerEntries: any[] = [];\r\n        if (fs.existsSync(this.ledgerEntriesFile)) {\r\n          try {\r\n            const fileContent = fs.readFileSync(this.ledgerEntriesFile, 'utf-8');\r\n            const existing = JSON.parse(fileContent);\r\n            if (existing.ledgerEntries && Array.isArray(existing.ledgerEntries)) {\r\n              existingLedgerEntries = existing.ledgerEntries;\r\n            }\r\n          } catch (err: any) {\r\n            console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load ledger entries from separate file: ${err.message}`);\r\n          }\r\n        } else if (fs.existsSync(this.persistenceFile)) {\r\n          // Fallback to old file for backward compatibility\r\n          try {\r\n            const fileContent = fs.readFileSync(this.persistenceFile, 'utf-8');\r\n            const existing = JSON.parse(fileContent);\r\n            if (existing.ledgerEntries && Array.isArray(existing.ledgerEntries)) {\r\n              existingLedgerEntries = existing.ledgerEntries;\r\n            }\r\n          } catch (err: any) {\r\n            console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load ledger entries from old file: ${err.message}`);\r\n          }\r\n        }\r\n        \r\n        // Load existing gardens from separate file (or old file for backward compatibility)\r\n        let existingIndexers: any[] = [];\r\n        if (fs.existsSync(this.gardensFile)) {\r\n          try {\r\n            const fileContent = fs.readFileSync(this.gardensFile, 'utf-8');\r\n            const existing = JSON.parse(fileContent);\r\n            const gardensFromFile = existing.gardens || existing.indexers;\r\n            if (gardensFromFile && Array.isArray(gardensFromFile)) {\r\n              existingIndexers = gardensFromFile;\r\n            }\r\n          } catch (err: any) {\r\n            console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load gardens from separate file: ${err.message}`);\r\n          }\r\n        } else if (fs.existsSync(this.persistenceFile)) {\r\n          // Fallback to old file for backward compatibility\r\n          try {\r\n            const fileContent = fs.readFileSync(this.persistenceFile, 'utf-8');\r\n            const existing = JSON.parse(fileContent);\r\n            const gardensFromFile = existing.gardens || existing.indexers;\r\n            if (gardensFromFile && Array.isArray(gardensFromFile)) {\r\n              existingIndexers = gardensFromFile;\r\n            }\r\n            // Backward compatibility: Migrate tokenIndexers to gardens array if it exists (non-ROOT only)\r\n            if (!DEPLOYED_AS_ROOT && existing.tokenIndexers && Array.isArray(existing.tokenIndexers)) {\r\n              console.log(`\uD83D\uDCCB [Redis Persistence] Found tokenIndexers field - migrating to gardens array`);\r\n              const existingTokenIds = new Set(existingIndexers.map((idx: any) => idx.id));\r\n              for (const tokenIdx of existing.tokenIndexers) {\r\n                if (!existingTokenIds.has(tokenIdx.id)) {\r\n                  existingIndexers.push(tokenIdx);\r\n                }\r\n              }\r\n            }\r\n          } catch (err: any) {\r\n            console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load gardens from old file: ${err.message}`);\r\n          }\r\n        }\r\n\r\n        // Merge: use new data if provided, otherwise keep existing\r\n        const finalLedgerEntries = ledgerEntries !== undefined ? ledgerEntries : existingLedgerEntries;\r\n        // CRITICAL: In ROOT mode, use in-memory arrays as source of truth, NOT the file\r\n        // The file might have duplicates from previous bad saves - we must use current in-memory state\r\n        let finalIndexers: any[];\r\n        if (DEPLOYED_AS_ROOT) {\r\n          // ROOT mode: Use in-memory arrays (GARDENS + TOKEN_GARDENS) as single source of truth\r\n          // Do NOT read from file - that would reintroduce duplicates\r\n          const allInMemoryIndexers = [...GARDENS, ...TOKEN_GARDENS];\r\n          finalIndexers = allInMemoryIndexers;\r\n        } else {\r\n          // Non-ROOT mode: use provided or existing from file\r\n          finalIndexers = indexers !== undefined ? indexers : existingIndexers;\r\n        }\r\n        \r\n        // CRITICAL: Always deduplicate gardens before saving to prevent duplicates\r\n        // This is essential because saveLedgerEntries() can trigger saves that reload duplicates from file\r\n        const originalCount = finalIndexers.length;\r\n        const deduplicatedGardens = new Map<string, any>();\r\n        for (const garden of finalIndexers) {\r\n          const existing = deduplicatedGardens.get(garden.id);\r\n          if (!existing) {\r\n            deduplicatedGardens.set(garden.id, garden);\r\n          } else {\r\n            // Prefer the one with certificate\r\n            const hasCert = !!(garden as any).certificate;\r\n            const existingHasCert = !!(existing as any).certificate;\r\n            if (hasCert && !existingHasCert) {\r\n              deduplicatedGardens.set(garden.id, garden);\r\n              console.warn(`\u26A0\uFE0F  [Indexer Persistence] Found duplicate garden ${garden.id} in savePersistence - keeping version with certificate`);\r\n            } else {\r\n              console.warn(`\u26A0\uFE0F  [Indexer Persistence] Found duplicate garden ${garden.id} in savePersistence - keeping existing version`);\r\n            }\r\n          }\r\n        }\r\n        finalIndexers = Array.from(deduplicatedGardens.values());\r\n        \r\n        if (originalCount !== finalIndexers.length) {\r\n          console.warn(`\u26A0\uFE0F  [Indexer Persistence] Removed ${originalCount - finalIndexers.length} duplicate(s) from gardens array before saving`);\r\n        }\r\n        \r\n        // CRITICAL: Use ServiceRegistry2 (new implementation) as the source of truth\r\n        // ServiceRegistry2 is the primary storage, ROOT_CA_SERVICE_REGISTRY is kept for backward compatibility only\r\n        let servicesToSave: ServiceProviderWithCert[] = [];\r\n        try {\r\n          const { getServiceRegistry2 } = require('./serviceRegistry2');\r\n          const serviceRegistry2 = getServiceRegistry2();\r\n          servicesToSave = serviceRegistry2.getAllProviders();\r\n          console.log(`\uD83D\uDD0D [savePersistence] ServiceRegistry2 has ${serviceRegistry2.getCount()} providers`);\r\n          console.log(`\uD83D\uDD0D [savePersistence] Providers:`, servicesToSave.map(p => `${p.id}(${p.serviceType},${p.gardenId})`).join(', '));\r\n          console.log(`\uD83D\uDD0D [savePersistence] Saving ${servicesToSave.length} providers from ServiceRegistry2 (NO FILTERING)`);\r\n          \r\n          // CRITICAL: Also sync to ROOT_CA_SERVICE_REGISTRY for backward compatibility\r\n          // This ensures both systems stay in sync during transition\r\n          for (const provider of servicesToSave) {\r\n            const existing = ROOT_CA_SERVICE_REGISTRY.find(p => p.id === provider.id);\r\n            if (!existing) {\r\n              ROOT_CA_SERVICE_REGISTRY.push(provider);\r\n              console.log(`\uD83D\uDD0D [savePersistence] Synced provider ${provider.id} to ROOT_CA_SERVICE_REGISTRY`);\r\n            }\r\n          }\r\n        } catch (err: any) {\r\n          // Fallback to old ROOT_CA_SERVICE_REGISTRY if ServiceRegistry2 is not available\r\n          if (err.message.includes('not initialized')) {\r\n            console.warn(`\u26A0\uFE0F  [savePersistence] ServiceRegistry2 not initialized, falling back to ROOT_CA_SERVICE_REGISTRY`);\r\n            servicesToSave = Array.from(ROOT_CA_SERVICE_REGISTRY);\r\n            console.log(`\uD83D\uDD0D [savePersistence] ROOT_CA_SERVICE_REGISTRY has ${ROOT_CA_SERVICE_REGISTRY.length} providers`);\r\n          } else {\r\n            throw err;\r\n          }\r\n        }\r\n        \r\n        const serviceRegistry = servicesToSave.map(p => {\r\n          const provider: any = {\r\n            id: p.id,\r\n            name: p.name,\r\n            serviceType: p.serviceType,\r\n            location: p.location,\r\n            bond: p.bond,\r\n            reputation: p.reputation,\r\n            status: p.status,\r\n            uuid: p.uuid,\r\n            apiEndpoint: p.apiEndpoint,\r\n              gardenId: p.gardenId // Use gardenId in persistence file\r\n          };\r\n          // Include Snake-specific fields if present\r\n          if (p.insuranceFee !== undefined) provider.insuranceFee = p.insuranceFee;\r\n          if (p.iGasMultiplier !== undefined) provider.iGasMultiplier = p.iGasMultiplier;\r\n          if (p.iTaxMultiplier !== undefined) provider.iTaxMultiplier = p.iTaxMultiplier;\r\n          if (p.maxInfluence !== undefined) provider.maxInfluence = p.maxInfluence;\r\n          if (p.contextsAllowed !== undefined) provider.contextsAllowed = p.contextsAllowed;\r\n          if (p.contextsForbidden !== undefined) provider.contextsForbidden = p.contextsForbidden;\r\n          if (p.adCapabilities !== undefined) provider.adCapabilities = p.adCapabilities;\r\n          return provider;\r\n        });\r\n\r\n        // REFACTOR: Save to separate files\r\n        const timestamp = new Date().toISOString();\r\n        \r\n        // Save wallet balances to main file\r\n        const walletData = {\r\n          walletBalances,\r\n          lastSaved: timestamp\r\n        };\r\n        fs.writeFileSync(this.persistenceFile, JSON.stringify(walletData, null, 2), 'utf-8');\r\n        console.log(`\uD83D\uDCBE [Redis Persistence] Saved ${Object.keys(walletBalances).length} wallet entries to ${this.persistenceFile}`);\r\n        \r\n        // Save ledger entries to separate file\r\n        // CRITICAL: Always save ledger entries, even if empty, to ensure file exists and is up-to-date\r\n        // This ensures that when entries are added, they will be persisted correctly\r\n        const ledgerData = {\r\n          ledgerEntries: finalLedgerEntries,\r\n          lastSaved: timestamp\r\n        };\r\n        fs.writeFileSync(this.ledgerEntriesFile, JSON.stringify(ledgerData, null, 2), 'utf-8');\r\n        console.log(`\uD83D\uDCBE [Redis Persistence] Saved ${finalLedgerEntries.length} ledger entries to ${this.ledgerEntriesFile}`);\r\n        if (finalLedgerEntries.length > 0) {\r\n          console.log(`\uD83D\uDCBE [Redis Persistence] Entry types: ${finalLedgerEntries.map((e: any) => e.serviceType || 'unknown').join(', ')}`);\r\n        }\r\n        \r\n        // Save gardens to separate file (only if we have gardens or the file exists)\r\n        // CRITICAL: In ROOT mode, gardens are saved via immediate save, but we still save here for non-ROOT mode\r\n        if (finalIndexers.length > 0 || fs.existsSync(this.gardensFile)) {\r\n          const gardensData = {\r\n            gardens: finalIndexers, // CRITICAL: All indexers (regular and token) are in 'gardens' array\r\n            lastSaved: timestamp\r\n          };\r\n          fs.writeFileSync(this.gardensFile, JSON.stringify(gardensData, null, 2), 'utf-8');\r\n        const tokenIndexerCount = finalIndexers.filter((idx: any) => \r\n          idx.tokenServiceType === 'dex' || (idx.serviceType === 'dex' && idx.id && idx.id.startsWith('T'))\r\n        ).length;\r\n        const regularIndexerCount = finalIndexers.length - tokenIndexerCount;\r\n          console.log(`\uD83D\uDCBE [Redis Persistence] Saved ${finalIndexers.length} total gardens (${regularIndexerCount} regular + ${tokenIndexerCount} token) to ${this.gardensFile}`);\r\n        }\r\n        \r\n        // Save service registry to separate file\r\n        // CRITICAL: Always save service registry, even if empty, to ensure file exists\r\n        // But log a warning if it's empty (shouldn't happen - infrastructure providers should always exist)\r\n        if (serviceRegistry.length === 0) {\r\n          console.warn(`\u26A0\uFE0F  [ServiceRegistry Persistence] WARNING: Service registry is empty! ROOT_CA_SERVICE_REGISTRY has ${ROOT_CA_SERVICE_REGISTRY.length} providers, but none have valid gardenId.`);\r\n          console.warn(`\u26A0\uFE0F  [ServiceRegistry Persistence] Providers in ROOT_CA_SERVICE_REGISTRY: ${ROOT_CA_SERVICE_REGISTRY.map(p => `${p.id} (gardenId: ${p.gardenId || 'MISSING'})`).join(', ')}`);\r\n        }\r\n        const serviceRegistryData = {\r\n          serviceRegistry: serviceRegistry,\r\n          lastSaved: timestamp\r\n        };\r\n        fs.writeFileSync(this.serviceRegistryFile, JSON.stringify(serviceRegistryData, null, 2), 'utf-8');\r\n        console.log(`\uD83D\uDCBE [Redis Persistence] Saved ${serviceRegistry.length} service providers to ${this.serviceRegistryFile}`);\r\n      } catch (err: any) {\r\n        console.error(`\u274C [Redis Persistence] Failed to save persistence file: ${err.message}`);\r\n      }\r\n    }, this.SAVE_DELAY_MS);\r\n  }\r\n  \r\n  // Public method to save ledger entries\r\n  // CRITICAL: ROOT CA ledger entries must be persisted IMMEDIATELY (no debounce)\r\n  // This is a ROOT CA operation - it must be saved synchronously to ensure data integrity\r\n  saveLedgerEntries(ledgerEntries: any[]): void {\r\n    if (!ledgerEntries || !Array.isArray(ledgerEntries)) {\r\n      console.error(`\u274C [Redis Persistence] Invalid ledgerEntries provided to saveLedgerEntries:`, typeof ledgerEntries);\r\n      return;\r\n    }\r\n    console.log(`\uD83D\uDCBE [Redis Persistence] \uD83D\uDD10 ROOT CA: saveLedgerEntries called with ${ledgerEntries.length} entries (IMMEDIATE PERSISTENCE)`);\r\n    if (ledgerEntries.length > 0) {\r\n      const serviceTypes = ledgerEntries.map((e: any) => e.serviceType || 'unknown');\r\n      const entryIds = ledgerEntries.map((e: any) => e.entryId || 'no-id').slice(0, 5);\r\n      console.log(`\uD83D\uDCBE [Redis Persistence] Entry service types: ${serviceTypes.join(', ')}`);\r\n      console.log(`\uD83D\uDCBE [Redis Persistence] Entry IDs (first 5): ${entryIds.join(', ')}`);\r\n    } else {\r\n      console.warn(`\u26A0\uFE0F [Redis Persistence] WARNING: saveLedgerEntries called with EMPTY array! This will overwrite existing entries!`);\r\n    }\r\n    \r\n    // CRITICAL: For ROOT CA ledger entries, save IMMEDIATELY (no debounce)\r\n    // Clear any pending debounced save for ledger entries\r\n    if (this.saveTimeout) {\r\n      clearTimeout(this.saveTimeout);\r\n      this.saveTimeout = null;\r\n    }\r\n    \r\n    // Save immediately (synchronously) for ROOT CA ledger entries\r\n    this.savePersistenceImmediate(ledgerEntries);\r\n  }\r\n  \r\n  // Immediate persistence for ROOT CA ledger entries (no debounce)\r\n  private savePersistenceImmediate(ledgerEntries?: any[]): void {\r\n    try {\r\n      // CRITICAL: Load existing wallet balances FIRST to preserve them\r\n      let existingWalletBalances: Record<string, string> = {};\r\n      \r\n      if (fs.existsSync(this.persistenceFile)) {\r\n        try {\r\n          const fileContent = fs.readFileSync(this.persistenceFile, 'utf-8');\r\n          const existing = JSON.parse(fileContent);\r\n          if (existing.walletBalances && typeof existing.walletBalances === 'object') {\r\n            existingWalletBalances = existing.walletBalances;\r\n          }\r\n        } catch (err: any) {\r\n          console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load existing wallet balances: ${err.message}`);\r\n        }\r\n      }\r\n      \r\n      // Start with existing wallet balances from file (preserve them)\r\n      const walletBalances: Record<string, string> = { ...existingWalletBalances };\r\n      \r\n      // Update wallet balances from in-memory\r\n      for (const [key, value] of this.data.entries()) {\r\n        if (key.startsWith('wallet:balance:')) {\r\n          const balanceValue = typeof value === 'string' ? value : JSON.stringify(value);\r\n          const balanceNum = parseFloat(balanceValue);\r\n          if (!isNaN(balanceNum) && balanceNum > 0) {\r\n            walletBalances[key] = balanceValue;\r\n          }\r\n        } else if (key.startsWith('wallet:audit:')) {\r\n          walletBalances[key] = typeof value === 'string' ? value : JSON.stringify(value);\r\n        }\r\n      }\r\n\r\n      // Load existing ledger entries from separate file\r\n      let existingLedgerEntries: any[] = [];\r\n      if (fs.existsSync(this.ledgerEntriesFile)) {\r\n        try {\r\n          const fileContent = fs.readFileSync(this.ledgerEntriesFile, 'utf-8');\r\n          const existing = JSON.parse(fileContent);\r\n          if (existing.ledgerEntries && Array.isArray(existing.ledgerEntries)) {\r\n            existingLedgerEntries = existing.ledgerEntries;\r\n          }\r\n        } catch (err: any) {\r\n          console.warn(`\u26A0\uFE0F  [Redis Persistence] Failed to load ledger entries from separate file: ${err.message}`);\r\n        }\r\n      }\r\n      \r\n      // CRITICAL: Use provided ledger entries (ROOT CA is source of truth)\r\n      // Merge with existing to avoid duplicates, but prefer new entries\r\n      const finalLedgerEntries = ledgerEntries !== undefined ? ledgerEntries : existingLedgerEntries;\r\n      \r\n      // Deduplicate by entryId (prefer newer entries)\r\n      const deduplicatedEntries = new Map<string, any>();\r\n      for (const entry of finalLedgerEntries) {\r\n        if (entry.entryId) {\r\n          const existing = deduplicatedEntries.get(entry.entryId);\r\n          if (!existing || (entry.timestamp && existing.timestamp && entry.timestamp > existing.timestamp)) {\r\n            deduplicatedEntries.set(entry.entryId, entry);\r\n          }\r\n        }\r\n      }\r\n      const uniqueLedgerEntries = Array.from(deduplicatedEntries.values());\r\n      \r\n      // REFACTOR: Save to separate files\r\n      const timestamp = new Date().toISOString();\r\n      \r\n      // Save wallet balances to main file\r\n      const walletData = {\r\n        walletBalances,\r\n        lastSaved: timestamp\r\n      };\r\n      fs.writeFileSync(this.persistenceFile, JSON.stringify(walletData, null, 2), 'utf-8');\r\n      console.log(`\uD83D\uDCBE [Redis Persistence] Saved ${Object.keys(walletBalances).length} wallet entries to ${this.persistenceFile}`);\r\n      \r\n      // CRITICAL: Save ledger entries IMMEDIATELY to separate file (ROOT CA operation)\r\n      const ledgerData = {\r\n        ledgerEntries: uniqueLedgerEntries,\r\n        lastSaved: timestamp\r\n      };\r\n      fs.writeFileSync(this.ledgerEntriesFile, JSON.stringify(ledgerData, null, 2), 'utf-8');\r\n      console.log(`\uD83D\uDCBE [Redis Persistence] \uD83D\uDD10 ROOT CA: IMMEDIATELY saved ${uniqueLedgerEntries.length} ledger entries to ${this.ledgerEntriesFile}`);\r\n      if (uniqueLedgerEntries.length > 0) {\r\n        console.log(`\uD83D\uDCBE [Redis Persistence] Entry types: ${uniqueLedgerEntries.map((e: any) => e.serviceType || 'unknown').join(', ')}`);\r\n        console.log(`\uD83D\uDCBE [Redis Persistence] Entry statuses: ${uniqueLedgerEntries.map((e: any) => e.status || 'unknown').join(', ')}`);\r\n      }\r\n    } catch (err: any) {\r\n      console.error(`\u274C [Redis Persistence] CRITICAL: Failed to save ledger entries IMMEDIATELY: ${err.message}`);\r\n      console.error(`\u274C [Redis Persistence] Stack:`, err.stack);\r\n    }\r\n  }\r\n  \r\n  // Public method to save indexers\r\n  // CRITICAL: In ROOT mode, indexers are saved via immediate save in /api/wizard/create-indexer\r\n  // This method should NOT be used in ROOT mode - persistence file is the single source of truth\r\n  saveIndexers(indexers: any[]): void {\r\n    if (DEPLOYED_AS_ROOT) {\r\n      console.log(`\uD83D\uDCCB [Indexer Persistence] ROOT mode: Skipping saveIndexers() - indexers are saved via immediate save in /api/wizard/create-indexer`);\r\n      return;\r\n    }\r\n    this.savePersistence(undefined, indexers);\r\n  }\r\n  \r\n  // Public method to save ServiceRegistry (for debugging)\r\n  // CRITICAL: This should ONLY save ServiceRegistry, NOT indexers\r\n  // Indexers are saved separately via the immediate save in /api/wizard/create-indexer\r\n  // In ROOT mode, this can be called during initialization to populate the persistence file\r\n  saveServiceRegistry(): void {\r\n    // In ROOT mode, allow saving during initialization to populate empty persistence file\r\n    // But skip if called during normal operation (indexers are saved separately)\r\n    if (DEPLOYED_AS_ROOT) {\r\n      // Allow saving during initialization - this helps populate empty persistence files\r\n      // The check for whether to save is handled by the caller\r\n    }\r\n    \r\n    // IMPORTANT: This used to do huge console logs + writeFileSync, which can freeze the server for seconds on Windows.\r\n    // Make it debounced + async (and quiet by default).\r\n    this.serviceRegistrySavePending = true;\r\n    if (this.serviceRegistrySaveTimer) return;\r\n\r\n    const verbose =\r\n      String(process.env.EDEN_DEBUG_SERVICE_REGISTRY_PERSIST_VERBOSE || \"\").toLowerCase() === \"true\";\r\n\r\n    this.serviceRegistrySaveTimer = setTimeout(() => {\r\n      this.serviceRegistrySaveTimer = null;\r\n      if (!this.serviceRegistrySavePending) return;\r\n      this.serviceRegistrySavePending = false;\r\n\r\n      void (async () => {\r\n        // REFACTOR: Save ServiceRegistry to separate file\r\n        // CRITICAL: Preserve existing gardenId assignments from file - don't overwrite with hardcoded defaults\r\n        try {\r\n      // Load existing service registry from file to preserve indexerId assignments\r\n      let existingProviders: Map<string, any> = new Map();\r\n      if (fs.existsSync(this.serviceRegistryFile)) {\r\n        try {\r\n          const fileContent = await fs.promises.readFile(this.serviceRegistryFile, \"utf-8\");\r\n          const persisted = JSON.parse(fileContent);\r\n          if (persisted.serviceRegistry && Array.isArray(persisted.serviceRegistry)) {\r\n            for (const provider of persisted.serviceRegistry) {\r\n              // Use gardenId (standardized field name)\r\n              const gardenId = provider.gardenId;\r\n              if (gardenId) {\r\n                // Store with gardenId\r\n                existingProviders.set(provider.id, { ...provider, gardenId: gardenId });\r\n              }\r\n            }\r\n            if (verbose) {\r\n              console.log(\r\n                `\uD83D\uDCC2 [ServiceRegistry Persistence] Loaded ${existingProviders.size} existing providers from file to preserve assignments`\r\n              );\r\n            }\r\n          }\r\n        } catch (err: any) {\r\n          console.warn(`\u26A0\uFE0F  [ServiceRegistry Persistence] Failed to load existing file: ${err.message}`);\r\n        }\r\n      }\r\n      \r\n      if (verbose) {\r\n        console.log(`\uD83D\uDCCB [In-Memory Service Registry] BEFORE save - Total: ${ROOT_CA_SERVICE_REGISTRY.length}`);\r\n        console.log(`\uD83D\uDCCB [In-Memory Service Registry] All providers:`, ROOT_CA_SERVICE_REGISTRY.map(p => ({\r\n          id: p.id,\r\n          name: p.name,\r\n          serviceType: p.serviceType,\r\n          gardenId: p.gardenId || 'MISSING'\r\n        })));\r\n      }\r\n      \r\n      // Update ServiceRegistry ONLY (do not touch gardens)\r\n      // NO FILTERING - Save everything in memory as-is (in-memory is source of truth)\r\n      const servicesToSave = ROOT_CA_SERVICE_REGISTRY; // Save ALL providers, no filtering\r\n      \r\n      if (verbose) {\r\n        console.log(`\uD83D\uDCCB [In-Memory Service Registry] Saving ALL ${servicesToSave.length} providers (NO FILTERING)`);\r\n      }\r\n      \r\n      const serviceRegistry = servicesToSave.map(p => {\r\n        // CRITICAL: For NEW providers (not in file), use in-memory value\r\n        // For EXISTING providers (in file), preserve file value to maintain assignments\r\n        const existingProvider = existingProviders.get(p.id);\r\n        // If provider exists in file, preserve its gardenId (file is source of truth for existing assignments)\r\n        // If provider is NEW (not in file), use in-memory value (this is how new providers get saved)\r\n        const preservedGardenId = existingProvider ? (existingProvider.gardenId || p.gardenId) : p.gardenId;\r\n        \r\n        // Log if we're preserving a different value from file\r\n        if (verbose) {\r\n          if (existingProvider && existingProvider.gardenId && existingProvider.gardenId !== p.gardenId) {\r\n            console.log(`\uD83D\uDCBE [ServiceRegistry Persistence] Preserving ${p.name} (${p.id}) gardenId \"${preservedGardenId}\" from file (in-memory has \"${p.gardenId}\")`);\r\n          } else if (!existingProvider) {\r\n            console.log(`\uD83D\uDCBE [ServiceRegistry Persistence] Saving NEW provider ${p.name} (${p.id}) with gardenId \"${preservedGardenId}\"`);\r\n          }\r\n        }\r\n        \r\n        const provider: any = {\r\n          id: p.id,\r\n          name: p.name,\r\n          serviceType: p.serviceType,\r\n          location: p.location,\r\n          bond: p.bond,\r\n          reputation: p.reputation,\r\n          status: p.status,\r\n          uuid: p.uuid,\r\n          apiEndpoint: p.apiEndpoint,\r\n          gardenId: preservedGardenId // Use gardenId in persistence file (indexerId is the in-memory field name)\r\n        };\r\n        \r\n        // Preserve other fields from file if they exist\r\n        if (existingProvider) {\r\n          if (existingProvider.insuranceFee !== undefined) provider.insuranceFee = existingProvider.insuranceFee;\r\n          if (existingProvider.iGasMultiplier !== undefined) provider.iGasMultiplier = existingProvider.iGasMultiplier;\r\n          if (existingProvider.iTaxMultiplier !== undefined) provider.iTaxMultiplier = existingProvider.iTaxMultiplier;\r\n          if (existingProvider.maxInfluence !== undefined) provider.maxInfluence = existingProvider.maxInfluence;\r\n          if (existingProvider.contextsAllowed !== undefined) provider.contextsAllowed = existingProvider.contextsAllowed;\r\n          if (existingProvider.contextsForbidden !== undefined) provider.contextsForbidden = existingProvider.contextsForbidden;\r\n          if (existingProvider.adCapabilities !== undefined) provider.adCapabilities = existingProvider.adCapabilities;\r\n        } else {\r\n          // Only include these fields if provider is new (not in file)\r\n        if (p.insuranceFee !== undefined) provider.insuranceFee = p.insuranceFee;\r\n        if (p.iGasMultiplier !== undefined) provider.iGasMultiplier = p.iGasMultiplier;\r\n        if (p.iTaxMultiplier !== undefined) provider.iTaxMultiplier = p.iTaxMultiplier;\r\n        if (p.maxInfluence !== undefined) provider.maxInfluence = p.maxInfluence;\r\n        if (p.contextsAllowed !== undefined) provider.contextsAllowed = p.contextsAllowed;\r\n        if (p.contextsForbidden !== undefined) provider.contextsForbidden = p.contextsForbidden;\r\n        if (p.adCapabilities !== undefined) provider.adCapabilities = p.adCapabilities;\r\n        }\r\n        \r\n        return provider;\r\n      });\r\n      \r\n      // REFACTOR: Save to separate file\r\n      // CRITICAL: Always save service registry, even if empty, to ensure file exists\r\n      // But log a warning if it's empty (shouldn't happen - infrastructure providers should always exist)\r\n      if (serviceRegistry.length === 0) {\r\n        console.warn(`\u26A0\uFE0F  [ServiceRegistry Persistence] WARNING: Service registry is empty! ROOT_CA_SERVICE_REGISTRY has ${ROOT_CA_SERVICE_REGISTRY.length} providers.`);\r\n        console.warn(`\u26A0\uFE0F  [ServiceRegistry Persistence] Providers in ROOT_CA_SERVICE_REGISTRY: ${ROOT_CA_SERVICE_REGISTRY.map(p => `${p.id} (gardenId: ${p.gardenId || 'MISSING'})`).join(', ')}`);\r\n        console.warn(`\u26A0\uFE0F  [ServiceRegistry Persistence] Providers filtered out: ${ROOT_CA_SERVICE_REGISTRY.filter(p => !p.gardenId || p.gardenId === null || p.gardenId === undefined).map(p => `${p.id}`).join(', ')}`);\r\n      }\r\n      const serviceRegistryData = {\r\n        serviceRegistry: serviceRegistry,\r\n        lastSaved: new Date().toISOString()\r\n      };\r\n      \r\n      await fs.promises.writeFile(this.serviceRegistryFile, JSON.stringify(serviceRegistryData, null, 2), \"utf-8\");\r\n\r\n      if (verbose) {\r\n        console.log(\r\n          `\uD83D\uDCBE [ServiceRegistry Persistence] Saved ${serviceRegistry.length} service providers to ${this.serviceRegistryFile} (preserved ${existingProviders.size} existing assignments)`\r\n        );\r\n      }\r\n        } catch (err: any) {\r\n          console.error(`\u274C [ServiceRegistry Persistence] Failed to save: ${err.message}`);\r\n        }\r\n      })();\r\n    }, 500);\r\n  }\r\n\r\n  async connect(): Promise<void> {\r\n    if (this.isConnected) return;\r\n    this.emit(\"connect\");\r\n    await new Promise(resolve => setTimeout(resolve, 10));\r\n    this.isConnected = true;\r\n    this.emit(\"ready\");\r\n  }\r\n\r\n  async ping(): Promise<string> {\r\n    return \"PONG\";\r\n  }\r\n\r\n  get isOpen(): boolean {\r\n    return this.isConnected;\r\n  }\r\n\r\n  // Simple key-value operations (for wallet balances)\r\n  async get(key: string): Promise<string | null> {\r\n    const value = this.data.get(key);\r\n    if (value === undefined) {\r\n      return null;\r\n    }\r\n    // If it's a string, return it directly\r\n    if (typeof value === 'string') {\r\n      return value;\r\n    }\r\n    // If it's an object (hash), return null (use hGet for hashes)\r\n    return null;\r\n  }\r\n\r\n  async set(key: string, value: string): Promise<void> {\r\n    this.data.set(key, value);\r\n    // Persist wallet-related keys immediately\r\n    if (key.startsWith('wallet:balance:') || key.startsWith('wallet:audit:')) {\r\n      this.savePersistence();\r\n    }\r\n  }\r\n\r\n  async del(key: string): Promise<number> {\r\n    const existed = this.data.has(key);\r\n    if (existed) {\r\n      this.data.delete(key);\r\n      // Persist wallet-related keys immediately\r\n      if (key.startsWith('wallet:balance:') || key.startsWith('wallet:audit:') || key.startsWith('wallet:hold:')) {\r\n        this.savePersistence();\r\n      }\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  // Get all keys matching a pattern (for wallet reset)\r\n  getKeysMatching(pattern: string): string[] {\r\n    const keys: string[] = [];\r\n    for (const key of this.data.keys()) {\r\n      if (key.startsWith(pattern)) {\r\n        keys.push(key);\r\n      }\r\n    }\r\n    return keys;\r\n  }\r\n\r\n  async hSet(key: string, value: any): Promise<number> {\r\n    if (typeof value === 'object' && value !== null) {\r\n      // Convert object to hash\r\n      const hash: Record<string, string> = {};\r\n      for (const [k, v] of Object.entries(value)) {\r\n        hash[k] = String(v);\r\n      }\r\n      this.data.set(key, hash);\r\n      return Object.keys(hash).length;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  async hGet(key: string, field: string): Promise<string | null> {\r\n    const hash = this.data.get(key);\r\n    if (hash && typeof hash === 'object') {\r\n      return hash[field] || null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  async xAdd(streamKey: string, id: string, fields: Record<string, string>): Promise<string> {\r\n    if (!this.streams.has(streamKey)) {\r\n      this.streams.set(streamKey, []);\r\n      this.streamCounters.set(streamKey, 0);\r\n    }\r\n\r\n    const stream = this.streams.get(streamKey)!;\r\n    let messageId: string;\r\n\r\n    if (id === \"*\") {\r\n      // Auto-generate ID: milliseconds-time-sequence\r\n      const counter = this.streamCounters.get(streamKey)!;\r\n      this.streamCounters.set(streamKey, counter + 1);\r\n      const timestamp = Date.now();\r\n      messageId = `${timestamp}-${counter}`;\r\n    } else {\r\n      messageId = id;\r\n    }\r\n\r\n    stream.push({ id: messageId, fields });\r\n    return messageId;\r\n  }\r\n\r\n  async xRead(\r\n    streams: Array<{ key: string; id: string }>,\r\n    options?: { BLOCK?: number; COUNT?: number }\r\n  ): Promise<Array<{ name: string; messages: Array<{ id: string; message: Record<string, string> }> }> | null> {\r\n    const results: Array<{ name: string; messages: Array<{ id: string; message: Record<string, string> }> }> = [];\r\n\r\n    for (const streamReq of streams) {\r\n      const stream = this.streams.get(streamReq.key);\r\n      if (!stream || stream.length === 0) {\r\n        if (options?.BLOCK) {\r\n          // Simulate blocking behavior\r\n          const blockTime = options.BLOCK || 0;\r\n          await new Promise(resolve => setTimeout(resolve, Math.min(blockTime, 1000)));\r\n          return null;\r\n        }\r\n        continue;\r\n      }\r\n\r\n      const messages: Array<{ id: string; message: Record<string, string> }> = [];\r\n      let startIndex = 0;\r\n\r\n      // Find starting position based on ID\r\n      if (streamReq.id === \"$\") {\r\n        // \"$\" means read only new messages - start from the end (no messages)\r\n        startIndex = stream.length;\r\n      } else if (streamReq.id !== \"0\") {\r\n        startIndex = stream.findIndex(msg => msg.id === streamReq.id);\r\n        if (startIndex === -1) startIndex = 0;\r\n        else startIndex += 1; // Start after the specified ID\r\n      }\r\n\r\n      const count = options?.COUNT || stream.length;\r\n      const endIndex = Math.min(startIndex + count, stream.length);\r\n\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        messages.push({\r\n          id: stream[i].id,\r\n          message: { ...stream[i].fields }\r\n        });\r\n      }\r\n\r\n      if (messages.length > 0) {\r\n        results.push({\r\n          name: streamReq.key,\r\n          messages\r\n        });\r\n      }\r\n    }\r\n\r\n    return results.length > 0 ? results : null;\r\n  }\r\n\r\n  async xGroupCreate(\r\n    streamKey: string,\r\n    groupName: string,\r\n    id: string,\r\n    options?: { MKSTREAM?: boolean }\r\n  ): Promise<void> {\r\n    if (!this.streams.has(streamKey)) {\r\n      if (options?.MKSTREAM) {\r\n        this.streams.set(streamKey, []);\r\n        this.streamCounters.set(streamKey, 0);\r\n      } else {\r\n        throw new Error(\"NOGROUP\");\r\n      }\r\n    }\r\n    \r\n    if (!this.consumerGroups.has(streamKey)) {\r\n      this.consumerGroups.set(streamKey, new Map());\r\n    }\r\n    \r\n    const groups = this.consumerGroups.get(streamKey)!;\r\n    if (groups.has(groupName)) {\r\n      throw new Error(\"BUSYGROUP\");\r\n    }\r\n    \r\n    groups.set(groupName, id);\r\n    this.pendingMessages.set(`${streamKey}:${groupName}`, new Map());\r\n  }\r\n\r\n  async xReadGroup(\r\n    groupName: string,\r\n    consumerName: string,\r\n    streams: Array<{ key: string; id: string }>,\r\n    options?: { COUNT?: number; BLOCK?: number }\r\n  ): Promise<Array<{ name: string; messages: Array<{ id: string; message: Record<string, string> }> }> | null> {\r\n    const results: Array<{ name: string; messages: Array<{ id: string; message: Record<string, string> }> }> = [];\r\n    \r\n    for (const streamReq of streams) {\r\n      const stream = this.streams.get(streamReq.key);\r\n      if (!stream || stream.length === 0) {\r\n        if (options?.BLOCK) {\r\n          await new Promise(resolve => setTimeout(resolve, Math.min(options.BLOCK || 0, 1000)));\r\n          return null;\r\n        }\r\n        continue;\r\n      }\r\n      \r\n      // Get consumer group last ID\r\n      const groups = this.consumerGroups.get(streamReq.key);\r\n      if (!groups || !groups.has(groupName)) {\r\n        throw new Error(\"NOGROUP\");\r\n      }\r\n      \r\n      const lastId = groups.get(groupName) || \"0\";\r\n      const messages: Array<{ id: string; message: Record<string, string> }> = [];\r\n      \r\n      let startIndex = 0;\r\n      if (streamReq.id === \">\") {\r\n        // Read new messages only\r\n        const lastIdIndex = stream.findIndex(msg => msg.id === lastId);\r\n        startIndex = lastIdIndex === -1 ? stream.length : lastIdIndex + 1;\r\n      } else {\r\n        startIndex = stream.findIndex(msg => msg.id === streamReq.id);\r\n        if (startIndex === -1) startIndex = 0;\r\n        else startIndex += 1;\r\n      }\r\n      \r\n      const count = options?.COUNT || stream.length;\r\n      const endIndex = Math.min(startIndex + count, stream.length);\r\n      \r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        messages.push({\r\n          id: stream[i].id,\r\n          message: { ...stream[i].fields }\r\n        });\r\n      }\r\n      \r\n      if (messages.length > 0) {\r\n        results.push({\r\n          name: streamReq.key,\r\n          messages\r\n        });\r\n      }\r\n    }\r\n    \r\n    return results.length > 0 ? results : null;\r\n  }\r\n\r\n  async xAck(streamKey: string, groupName: string, ...ids: string[]): Promise<number> {\r\n    const groups = this.consumerGroups.get(streamKey);\r\n    if (!groups || !groups.has(groupName)) {\r\n      return 0;\r\n    }\r\n    \r\n    // Update last processed ID\r\n    if (ids.length > 0) {\r\n      const lastId = ids[ids.length - 1];\r\n      groups.set(groupName, lastId);\r\n    }\r\n    \r\n    return ids.length;\r\n  }\r\n\r\n  async quit(): Promise<void> {\r\n    // Save persistence before quitting\r\n    if (this.saveTimeout) {\r\n      clearTimeout(this.saveTimeout);\r\n    }\r\n    // Force immediate save on quit (ledger entries passed separately)\r\n    try {\r\n      const walletBalances: Record<string, string> = {};\r\n      for (const [key, value] of this.data.entries()) {\r\n        if (key.startsWith('wallet:balance:') || key.startsWith('wallet:audit:')) {\r\n          walletBalances[key] = typeof value === 'string' ? value : JSON.stringify(value);\r\n        }\r\n      }\r\n      // Note: Ledger entries will be saved separately via saveLedgerEntries()\r\n      const persisted = {\r\n        walletBalances,\r\n        ledgerEntries: [], // Will be populated by saveLedgerEntries()\r\n        lastSaved: new Date().toISOString()\r\n      };\r\n      fs.writeFileSync(this.persistenceFile, JSON.stringify(persisted, null, 2), 'utf-8');\r\n      console.log(`\uD83D\uDCBE [Redis Persistence] Saved ${Object.keys(walletBalances).length} wallet entries on quit (ledger entries saved separately)`);\r\n    } catch (err: any) {\r\n      console.error(`\u274C [Redis Persistence] Failed to save on quit: ${err.message}`);\r\n    }\r\n    this.isConnected = false;\r\n    this.emit(\"end\");\r\n  }\r\n\r\n  on(event: string, listener: (...args: any[]) => void): this {\r\n    return super.on(event, listener);\r\n  }\r\n}\r\n\r\n"],
  "mappings": "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",
  "names": ["existingProvider"]
}
